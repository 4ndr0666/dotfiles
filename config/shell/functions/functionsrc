#!/bin/sh
# File: functionsrc
# Author: 4ndr0666
# Date: 10-15-24

# =========================================== // functionsrc //
# --- // KILL_PROCESS:
function copypath {
  # If no argument passed, use current directory
  local file="${1:-.}"

  # If argument is not an absolute path, prepend $PWD
  [[ $file = /* ]] || file="$PWD/$file"

  # Copy the absolute path without resolving symlinks
  # If clipcopy fails, exit the function with an error
  print -n "${file:a}" | clipcopy || return 1

  echo ${(%):-"%B${file:a}%b copied to clipboard."}
}

# --------------------------------------------------------- // DOWNSCALE_TO_1080P:
function downscale() {
    local input_file="$1"
    local output_file="${2:-output_1080p.mp4}"
    local quality="${3:-18}"  # Default CRF value for quality, lower is better

    # Validate input file presence
    if [[ -z "$input_file" ]]; then
        echo "Usage: downscale <path/to/media> [output_file_path] [quality]"
        return 1
    fi

    # Validate input file existence
    if [[ ! -f "$input_file" ]]; then
        echo "Error: Input file '$input_file' does not exist."
        return 1
    fi

    # Validate quality parameter
    if ! [[ "$quality" =~ ^[0-9]+$ ]]; then
        echo "Error: Quality parameter should be an integer."
        return 1
    fi

    # Ensure output file name is unique
    local base_name="${output_file%.*}"
    local extension="${output_file##*.}"
    local counter=1

    while [[ -f "$output_file" ]]; do
        output_file="${base_name}_${counter}.${extension}"
        ((counter++))
    done

    # Start downscale process using FFmpeg
    echo "Starting downscale process to 1080p..."
    ffmpeg -i "$input_file" \
           -vf "scale=1920x1080:force_original_aspect_ratio=decrease,pad=1920:1080:(ow-iw)/2:(oh-ih)/2" \
           -c:v libx264 -crf "$quality" -preset slow -c:a copy "$output_file"

    # Check if FFmpeg command was successful
    if [[ $? -eq 0 ]]; then
        echo "Downscale complete. Output saved to '$output_file'."
    else
	echo "Error: Downscale process failed."
    return 1
    fi
}

# ------------------------------------------------------------------- // Extract:
function extract() {
	clear; tput cup $(($(tput lines)/3)); tput bold
	set -f
	printf "%s\n\t" "$fx"
	printf "extract?[y/N]"
	read ans
	[ $ans = "y" ] && {
		case $fx in
			*.tar.bz2)   tar xjf $fx     ;;
			*.tar.gz)    tar xzf $fx     ;;
			*.bz2)       bunzip2 $fx     ;;
			*.rar)       unrar e $fx     ;;
			*.gz)        gunzip $fx      ;;
			*.tar)       tar xf $fx      ;;
			*.tbz2)      tar xjf $fx     ;;
			*.tgz)       tar xzf $fx     ;;
			*.zip)       unzip $fx       ;;
			*.Z)         uncompress $fx  ;;
			*.7z)        7z x $fx        ;;
			*.tar.xz)    tar xf $fx      ;;
			*.tar.zst)   tar xf $fx      ;;
		esac
}

# -------------------------------------------------------------------------- // Cd and ls:
cl() {
    # Default to HOME directory if no argument is provided
    local dir="${1:-$HOME}"

    # Check if the argument is a directory or a symbolic link to a directory
    if [[ -d "$dir" || -L "$dir" ]]; then
        cd "$dir" && lsd
    else
        # Standardized error message
        echo "zsh: cl: '$dir': No such file or directory"
    fi
}

# -------------------------------------------------------------- // MAKE_DIR_&_CD:
function mkcd() {
    if (( $# != 1 )); then
        echo 'Usage: mkcd <new-directory>'
        return 1
    fi

    local dir="$1"

    # Check if the directory is a valid path
    if [[ -z "$dir" ]]; then
        echo "Error: Directory name cannot be empty."
        return 1
    fi

    # Attempt to create the directory if it doesn't exist
    if [[ ! -d "$dir" ]]; then
        if mkdir -p "$dir"; then
            echo "Directory '$dir' created."
        else
            echo "Failed to create directory '$dir'."
            return 1
        fi
    else
        echo "Directory '$dir' already exists."
    fi

    # Change into the directory, with error checking
    if cd "$dir"; then
        echo "Switched to directory '$dir'."
    else
        echo "Failed to switch to directory '$dir'."
        return 1
    fi
}

# ---------------------------------------------------------- // MAKE_TMP_DIR_&_CD:
function cdt() {
    local tmp_dir

    if tmp_dir=$(mktemp -d 2>/dev/null); then
        echo "Created and switching to temporary directory: $tmp_dir"
        cd "$tmp_dir"
    else
        echo "Failed to create a temporary directory."
        return 1
    fi

    pwd
}

# --------------------------------------------------------------- // DECODE_URLS:
#function urldecode() {
#    if [[ -z "$1" ]]; then
#        echo "Usage: urldecode <encoded_string>"
#        return 1
#    fi

#    echo "$1" | awk '{gsub(/%([0-9A-Fa-f]{2})/, "\\x\\1"); print}' | xargs -0 echo -e
#}

# ------------------------------------------------------------- // TERMBIN:
#function termbin() {
#    if [[ -z "$1" ]]; then
#        echo "Usage: termbin <file>"
#        return 1
#    fi

#    if [[ ! -f "$1" ]]; then
#        echo "File not found: $1"
#        return 1
#    fi

#    if ! command -v nc &>/dev/null; then
#        echo "'nc' (netcat) is required but not installed."
#        return 1
#    fi

#    local url
#    url=$(nc termbin.com 9999 < "$1")

#    if [[ $? -eq 0 && -n "$url" ]]; then
#        echo "File uploaded successfully."
#        echo "URL: $url"
#    else
#        echo "Error: Failed to upload file."
#        return 1
#    fi
#}
