#!/usr/bin/env zsh

# ===================================== // ALIASRC by 4ndr0666 //

if [[ -o interactive ]]; then
    alias reload='exec zsh'
    alias mkdir='mkdir -pv'
    alias mkgpg="[ -d ~/.gnupg ] || (mkdir ~/.gnupg && cp /etc/pacman.d/gnupg/gpg.conf ~/.gnupg/ && echo 'done')"
fi

## Sudo

#for command in mount umount sv pacman updatedb su shutdown poweroff reboot; do
#    alias "$command"="sudo $command"
#done; unset command

## LS

#### Config 1
alias ls='exa -hlx --no-filesize --no-time --no-permissions --color=always --group-directories-first --icons=always'
alias la="lsd -aFlL --permission=rwx --color=always --group-directories-first --icon=always"
alias ll='exa -xXDa --color=always  --icons=always'
alias l.='exa -ax --sort=modified --color-scale-mode=gradient --color=always --group-directories-first --icons | grep "^\."'
#exa -aT -s new --color=always --group-directories-first --icons

#### Config 2
#alias l='ls'
#alias ls="ls -alhfN --time-style=long-iso --color=auto --group-directories-first"
#alias ll="ls -lFh --color=auto --group-directories-first --time-style=long-iso"
#alias la='exa -hFlBgmnsa -s new --git --octal-permissions --group-directories-first --icons'
#alias lt='ls -ltFh'
#alias ldot='ls -1FSsh'
alias LS='\ls -1FSsh'
#alias lart='ls -1Fcart'
#alias lrt='ls -1Fcrt'
#alias lm='ls -m'
alias lr='lsd -tr'
#alias lg='ls -l --group-directories-first'

#### Config 3
#alias l.='ls -d .* --color=auto'
#alias ll='ls -lh --color=auto'
#alias la='ls -lha --color=auto'
#alias lsd='ls -lhS --color=auto | grep -E "^d"'
#alias lsf='ls -lhS --color=auto | grep -E "^-"'
#alias lsp='ls -lhS --color=auto | grep -E "^l"'

#### Config 4
#alias ls='ls --group-directories-first --color'
#alias ll='ls -lhF'
#alias la='ls -lha'
#alias lt='ls -lhtr'
#alias lta='ls -lhatr'

#### Config 5
#alias lm='ls | more'
#alias ll='ls -lFh --group-directories-first'
#alias la='ls -alFh --group-directories-first'
#alias l1='ls -1F --group-directories-first'
#alias l1m='ls -1F --group-directories-first | more'
#alias lh='ls -ld .??*'
alias lsn='\ls | cat -n'

## LS Functions

#### Ls with Bat
alias lb='\ls | bat'

#### Ls on One Line
alias l1='lsd -1'

#### Ls symlinks
alias lta='\ls -ltrha'

#### List All Modified Files in Past 60 min
alias ls60='sudo find / -mmin 60 -type f'

#### List Files & Dirs Modified in Past Day
alias lsfdday='\ls *(m0)'

#### List Files Modified in Past Day
alias lsfday='\ls *(.m0)'

#### List 3 Newest
alias lsnew='\ls *(.om[1,3])'

#### List Most Recent Subdir
alias lssubdir='\ls -d *(/om[1])'


## Login Manager

alias tolightdm="sudo pacman -S lightdm lightdm-gtk-greeter lightdm-gtk-greeter-settings --noconfirm --needed ; sudo systemctl enable lightdm.service -f ; echo 'Lightdm is active - reboot now'"
alias tosddm="sudo pacman -S sddm --noconfirm --needed ; sudo systemctl enable sddm.service -f ; echo 'Sddm is active - reboot now'"
alias toly="sudo pacman -S ly --noconfirm --needed ; sudo systemctl enable ly.service -f ; echo 'Ly is active - reboot now'"
alias togdm="sudo pacman -S gdm --noconfirm --needed ; sudo systemctl enable gdm.service -f ; echo 'Gdm is active - reboot now'"
alias tolxdm="sudo pacman -S lxdm --noconfirm --needed ; sudo systemctl enable lxdm.service -f ; echo 'Lxdm is active - reboot now'"

## Shell

alias tobash="sudo chsh $USER -s /bin/bash && echo 'Now log out.'"
alias tozsh="sudo chsh $USER -s /bin/zsh && echo 'Now log out.'"
alias tofish="sudo chsh $USER -s /bin/fish && echo 'Now log out.'"

## Wayfire

#### reinstall dependencies
alias refreshwayfire='yay -S wayfire-plugins-extra-git wayfire-git wf-config-git wf-kill-git wf-osk-git wf-recorder-git'

# System General Aliases

alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
alias ......='cd ../../../../..'
alias s='sudo'
alias e='$EDITOR'
alias v='$EDITOR'
alias p="sudo pacman"
alias ka='killall'
alias cp='cp --preserve=all'
alias cpv='cp --preserve=all -v'
alias cpr='cp --preserve=all -R'
alias cpp='rsync -ahzXW --info=progress2'
alias mv='mv -iv'
alias rm='rm -vI'
alias bc='bc -l'
alias rmf='sudo -S rm -vI -rf'
alias rg="rg --sort path"
alias diff='colordiff -yW "$(tput cols)"'
alias rmdir='rm -vI --preserve root'
alias ln='ln -iv'
alias wget="wget -c"
alias curl="curl --user-agent 'noleak'"
alias df='df -h --exclude-type=squashfs --exclude-type=tmpfs --exclude-type=devtmpfs'
#alias cat='bat'
alias ccat="highlight --out-format=ansi"
alias showpath='echo $PATH | tr ":" "\n"'
alias rsync='rsync -vrPlu'
alias unhblock='hblock -S none -D none'
alias grep='grep --color=auto'
alias grepc='grep --color=always'
alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'
alias c='clear; echo; echo; seq 1 $(tput cols) | sort -R | spark | lolcat; echo; echo'
alias hw='sudo hwinfo --short'
alias lsb='lsblk -o NAME,FSTYPE,SIZE,MOUNTPOINT'
alias psa='ps auxf | less'
alias free='free -mt'
alias jctl='journalctl -p 3 -xb'
alias mapit="ifconfig -a | grep -Po '\b(?!255)(?:\d{1,3}\.){3}(?!255)\d{1,3}\b' | xargs nmap -A -p0-"
alias ports='ss -tunlp'
alias whatonline='lsof -P -i -n'
alias speedtest='curl -s https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.py | python3 -'
alias netspeed='ifstat -t -S -w'
alias dir5='du -cksh * | sort -hr | head -5'
alias dir10='du -cksh * | sort -hr | head -10'
alias dir='dir --color=auto'
alias vdir='vdir --color=auto'
alias watch='watch'
alias mem10='ps aux | sort -nk +4 | tail'
alias pacdiff='sudo -H DIFFPROG=meld pacdiff'
alias psgrep="ps aux | grep -v grep | grep -i -e VSZ -e"
alias myip='curl canhazip.com'
alias mybios='dmidecode -t bios'
filecount() {
    if [[ "$1" == "-l" ]]; then
        echo "Files in $PWD:"
        find "$PWD" -type f
    else
        echo "Total files in $PWD: $(find "$PWD" -type f | wc -l)"
    fi
}

lsmount() {
    if [[ -n "$1" ]]; then
        mount | column -t | grep "$1"
    else
        mount | column -t
    fi
}

whatdependson() {
    local search="$1"
    sudo pacman -Sii "$search" | grep "Required" | sed -e "s/Required By     : //g" | sed -e "s/  /\n/g"
}

findit() {
    if [[ -n "$1" ]]; then
        find . -type f -printf "%TY%Tm%Td\t%p\n" | sort | grep -i "$1"
    else
        return 1
    fi
}

archive() {
    local target="$1"
    local backup_dir="${2:-.}"

    if [[ -z "$target" ]]; then
        echo "Error: Please provide a file or directory to back up."
        return 1
    fi

    if [[ ! -e "$target" ]]; then
        echo "Error: The target '$target' does not exist."
        return 1
    fi

    local target_name
    target_name=$(basename "$target")
    local timestamp
    timestamp=$(date -u "+%h-%d-%Y_%H.%M%p")
    local backup_file="${backup_dir}/${target_name}_${timestamp}_backup.tar.gz"

    echo "Creating backup for '$target'..."

    # Check if we have write access to the backup directory and read access to the target
    if [[ ! -w "$backup_dir" || ! -r "$target" ]]; then
        echo "Insufficient permissions, attempting with sudo..."
        if sudo tar -czvf "$backup_file" "$target"; then
            echo "Backup successful with sudo: $backup_file"
        else
            echo "Error: Failed to create backup with sudo."
            return 1
        fi
    else
        if tar -czvf "$backup_file" "$target"; then
            echo "Backup successful: $backup_file"
        else
            echo "Error: Failed to create backup."
            return 1
        fi
    fi
}

alias untar='sudo tar xvf'

tarnow() {
    local target="$1"
    local backup_dir="${2:-.}"

    if [[ -z "$target" ]]; then
        echo "Provide dir to tarball."
        return 1
    fi

    if [[ ! -e "$target" ]]; then
        echo "Error: The target '$target' does not exist."
        return 1
    fi

    local target_name
    target_name=$(basename "$target")
    local timestamp
    timestamp=$(date -u "+%m-%d_%I:%M%p")
    local backup_file="${backup_dir}/${target_name}-${timestamp}.tar.gz"

    echo "Creating tarball for '$target'..."

    # Check if we have write access to the backup directory and read access to the target
    if [[ ! -w "$backup_dir" || ! -r "$target" ]]; then
        echo "Bypassed: permissions."
        if sudo tar -czvf "$backup_file" "$target"; then
            echo "Tarball successful: $backup_file"
        else
            echo "Error: permissions."
            return 1
        fi
    else
        if tar -czvf "$backup_file" "$target"; then
            echo "Tarball: $backup_file"
        else
            echo "Error: Failed to compress tarball."
            return 1
        fi
    fi
}

psmem() {
    local count="${1:-5}"
    echo "Top $count memory-consuming processes:"
    if ! ps aux --sort=-%mem | awk 'NR==1; NR>1 {print $0}' | head -n $((count + 1)); then
        echo "Error retrieving memory info."
        return 1
    fi
}

pscpu() {
    local count="${1:-5}"
    echo "Top $count CPU-consuming processes:"
    if ! ps aux --sort=-%cpu | awk 'NR==1; NR>1 {print $0}' | head -n $((count + 1)); then
        echo "Error retrieving CPU info."
        return 1
    fi
}

d0() {
    local target_dir="${1:-.}"
    find "$target_dir" -type f -size 0 -print0 | while IFS= read -r -d '' file; do
        read -r -p "Delete '$file'? [y/N] " response
        if [[ $response =~ ^[Yy]$ ]]; then
            rm -rf "$file"
            echo "Deleted: $file"
        else
            echo "Skipped: $file"
        fi
    done
}

## Xorg Display

alias xd='ls /usr/share/xsessions'
alias xdw="ls /usr/share/wayland-sessions"
alias xfix='echo "DISPLAY=:0 XAUTHORITY=$HOME/.Xauthority xterm"'
alias xi='sudo xbps-install'
alias xr='sudo xbps-remove -R'
alias xq='xbps-query'
alias xmerge='xrdb -merge ~/.Xresources'

# Permissions

## Chmod

alias chown='sudo chown --preserve-root'
alias chmod='sudo chmod --preserve-root'
alias chgrp='sudo chgrp --preserve-root'
alias chgpg='sudo chown -R $USER:$USER ~/.gnupg && sudo chmod 700 ~/.gnupg && sudo chmod 600 ~/.gnupg/*'
alias chtmp='sudo chown root:root /tmp && sudo chmod 1777 /tmp && sudo mount -o remount,exec /tmp'
alias lck='sudo chattr +i '
alias ulck='sudo chattr -i '
alias chlocal='sudo chown -R $USER:$USER ~/.config ~/.local && echo "Ownership of ~/.config and ~/.local changed to $USER."'
alias chnpm='sudo chown -R 1000:1000 /home/andro/.npm'
chpython() {
    local python_version
    python_version=$(python3 -c 'import sys; print(".".join(map(str, sys.version_info[:2])))')

    local site_packages_dir="/usr/lib/python${python_version}/site-packages"

    if [[ -d "$site_packages_dir" ]]; then
        echo "Setting ownership to root and permissions to 755 for: $site_packages_dir"
        if ! sudo chown -R root:root "$site_packages_dir"; then
            echo "Error: Failed to change ownership for $site_packages_dir."
            return 1
        fi
        if ! sudo chmod -R 755 "$site_packages_dir"; then
            echo "Error: Failed to set permissions for $site_packages_dir."
            return 1
        fi
        echo "Ownership and permissions set successfully for $site_packages_dir."
    else
        echo "Error: Directory $site_packages_dir not found for Python version $python_version."
    fi
}

chboot() {
    if ! sudo chmod -R 755 /boot/efi; then
        echo "Error: Failed to chmod /boot/efi."
        return 1
    fi
    if ! sudo chown -R root:root /boot/efi; then
        echo "Error: Failed to chown /boot/efi."
        return 1
    fi
    echo "Boot directory permissions reset appropriately."
}

chdirs() {
    if [[ -z "$1" ]]; then
        echo "Usage: chdirs <directory_path>"
        return 1
    elif [[ ! -d "$1" ]]; then
        echo "Error: '$1' is not a valid directory."
        return 1
    fi

    local target_dir="$1"
    echo "Setting permissions: U+rwx | G+rwx | O+rx for all directories in '$target_dir'..."

    if ! sudo find "$target_dir" -type d -exec chmod 755 {} +; then
        echo "Error: Failed to set permissions for directories in '$target_dir'."
        return 1
    fi

    echo "✔️ All dirs in '$target_dir' set to 755."
}

chfd() {
    if [[ -z "$1" ]]; then
        echo "Usage: chfdirs <file_or_dir_path>"
        return 1
    fi

    local target="$1"

    if [[ -f "$target" ]]; then
        # If it's a file, apply chmod 644
        echo "Setting permissions: U+rwx | G+rx | O+rx for file '$target'..."
        if ! sudo chmod 644 "$target"; then
            echo "Error: Failed to set permissions for file '$target'."
            return 1
        fi
    elif [[ -d "$target" ]]; then
        # If it's a directory, apply chmod 755 recursively
        echo "Setting permissions: U+rwx | G+rx | O+rx for all files in directory '$target'..."
        if ! sudo find "$target" -type f -exec chmod 755 {} +; then
            echo "Error: Failed to set permissions for files in directory '$target'."
            return 1
        fi
    else
        echo "Error: '$target' is not a valid file or directory."
        return 1
    fi

    echo "✔️ Successfully set permissions to 755 for '$target'."
}

chandro() {
    if [[ -z "$1" ]]; then
        echo "Usage: chandro [-R] <file_or_dir_path>"
        return 1
    fi

    # Check if recursive flag is provided
    local recursive=false
    if [[ "$1" == "-R" ]]; then
        recursive=true
        shift
    fi

    local target="$1"

    if [[ -z "$target" ]]; then
        echo "Error: No file or directory specified."
        return 1
    fi

    if [[ ! -e "$target" ]]; then
        echo "Error: '$target' does not exist."
        return 1
    fi

    echo "Setting ownership to 'andro:andro' and permissions to 775 for '$target'..."

    # Apply ownership and permissions
    if [[ "$recursive" == true ]]; then
        if ! sudo chown -R andro:andro "$target"; then
            echo "Error: Failed to change ownership for '$target'."
            return 1
        fi
        if ! sudo chmod -R 755 "$target"; then
            echo "Error: Failed to set permissions for '$target'."
            return 1
        fi
    else
        if ! sudo chown andro:andro "$target"; then
            echo "Error: Failed to change ownership for '$target'."
            return 1
        fi
        if ! sudo chmod 755 "$target"; then
            echo "Error: Failed to set permissions for '$target'."
            return 1
        fi
    fi

    echo "✔️ Successfully set ownership and permissions for '$target'."
}

chrootuser() {
    if [[ -z "$1" ]]; then
        echo "Usage: chrootuser [-R] <file_or_dir_path>"
        return 1
    fi

    # Check if recursive flag is provided
    local recursive=false
    if [[ "$1" == "-R" ]]; then
        recursive=true
        shift
    fi

    local target="$1"

    if [[ -z "$target" ]]; then
        echo "Error: No file or directory specified."
        return 1
    fi

    if [[ ! -e "$target" ]]; then
        echo "Error: '$target' does not exist."
        return 1
    fi

    echo "Setting ownership to 'root:root' and adjusting permissions for '$target'..."

    # Apply ownership and permissions
    if [[ "$recursive" == true ]]; then
        if ! sudo chown -R root:root "$target"; then
            echo "Error: Failed to change ownership for '$target'."
            return 1
        fi
        if ! sudo find "$target" -type d -exec chmod 755 {} +; then
            echo "Error: Failed to set directory permissions for '$target'."
            return 1
        fi
        if ! sudo find "$target" -type f -exec chmod 644 {} +; then
            echo "Error: Failed to set file permissions for '$target'."
            return 1
        fi
    else
        if ! sudo chown root:root "$target"; then
            echo "Error: Failed to change ownership for '$target'."
            return 1
        fi

        # Set permissions based on type
        if [[ -d "$target" ]]; then
            if ! sudo chmod 755 "$target"; then
                echo "Error: Failed to set permissions for '$target'."
                return 1
            fi
        elif [[ -f "$target" ]]; then
            if ! sudo chmod 644 "$target"; then
                echo "Error: Failed to set permissions for '$target'."
                return 1
            fi
        fi
    fi

    echo "✔️ Successfully set ownership and permissions for '$target'."
}

## System Admin & Maintenance:

alias update-grub2='sudo grub-install ... && sudo grub-mkconfig -o /boot/grub/grub.cfg'
alias update-grub="sudo grub-mkconfig -o /boot/grub/grub.cfg"
alias grub-mkconfig='sudo grub-mkconfig -o /boot/grub/grub.cfg'
alias iotop='sudo iotop -o'
alias addlbin='export PATH=/home/andro/.local/bin:$PATH'
alias whatkernel="ls /usr/lib/modules"
alias scr='systemctl -t service -a --state running --no-page --no-legend'
alias fixnvm='nvm use --delete-prefix v22.13.0 --silent'
alias fixnode='npm audit fix --force'
alias fixkeyboard='sudo localectl set-x11-keymap us'
alias listusers='cut -d: -f1 /etc/passwd | sort'
alias setlocales='sudo localectl set-locale LANG=en_US.UTF-8'
alias microcode='grep . /sys/devices/system/cpu/vulnerabilities/*'
alias audio="pactl info | grep 'Server Name'"
alias retry='until !!; do :; done'

#### Backup and restore /etc/skel
alias bupskel='sudo cp -Rf /etc/skel /var/recover/skel-backup-$(date +"%Y.%m.%d-%H.%M.%S") && echo "Backup of skel made."'
alias restoreskel='sudo cp -Rf /var/recover/skel-backup-*/. $HOME/ && echo "Restored from latest backup."'

#### Copy rc files from /etc/skel
#alias cb='cp /etc/skel/.bashrc ~/.bashrc && exec bash'
#alias cz='cp /etc/skel/.zshrc ~/.zshrc && echo "Copied."'
#alias cf='cp /etc/skel/.config/fish/config.fish ~/.config/fish/config.fish && echo "Copied."'

#fixo() {
#  [[ -d "$1" ]] &&
#    find "$1" -type d -print0 | xargs -0 chmod 755 && find "$1" -type f -print0 | xargs -0 chmod 644 ||
#    echo "$1 is not a directory."
#}
#fix() {
#  [[ -d "$1" ]] &&
#    find "$1" -type d -print0 | xargs -0 chmod 750 && find "$1" -type f -print0 | xargs -0 chmod 640 ||
#    echo "$1 is not a directory."
#}
#fixp() {
#  [[ -d "$1" ]] &&
#    find "$1" -type d -print0 | xargs -0 chmod 700 && find "$1" -type f -print0 | xargs -0 chmod 600 ||
#    echo "$1 is not a directory."
#}

# Program Specific

## Zathura

alias z='zathura --fork'

## Bat

#### Instead of `cmd --help` do `help cmd`:
alias bathelp='bat --plain --language=help'

help() {
    "$@" --help >/dev/null 2>&1 || "$@" -h >/dev/null 2>&1 | bathelp
}

alias man='batman'

#### Parses git syntax
batdiff() {
    git diff --name-only --relative --diff-filter=d | xargs bat --diff
}

## Lf

alias lf='lfub'
alias ref='shortcuts >/dev/null; source ${XDG_CONFIG_HOME:-$HOME/.config}/shellz/shortcutrc; source ${XDG_CONFIG_HOME:-$HOME/.config}/shellz/shortcutenvrc; source ${XDG_CONFIG_HOME:-$HOME/.config}/shellz/zshnameddirrc'

## Wf-recorder

#alias screenrecord="wf-recorder -a"
#alias screenrecord2="wf-recorder -a -c h264_vaapi -C aac -d /dev/dri/renderD128 --file=recording.mp4"

## FZF

#### Select files from dir and edit
fzscr() {
    local dir="${1:-/home/git/clone/scr}"
    local choice
    choice=$(find "$dir" -mindepth 1 \( -type d -o -executable -type f \) \
        ! -path '*/.git/*' -printf '%P\n' | sort -r | fzf --preview "cat '$dir/{}'" --preview-window=down:70%)
    if [ -n "$choice" ]; then
        if [ -d "$dir/$choice" ]; then
            echo "Selected directory: $dir/$choice"
        elif [ -x "$dir/$choice" ]; then
            echo "Executing $dir/$choice ..."
            "$dir/$choice"
        else
            echo "No script selected or script is not executable."
        fi
    else
        echo "No selection made."
    fi
}

## Kmon

alias kmon='sudo kmon --color blue --accent-color 15FFFF --unicode'

## FD

alias fd='fd --hidden --follow --exclude ".git"'
alias fd1='fd --exact-depth=1 --hidden --follow --exclude ".git"' # Keeps search depth at first level
fdde() {
    local case_flag=""
    local depth_flag=""

    # Enable case-insensitive search if the first argument is '-i'
    if [[ "$1" == "-i" ]]; then
        case_flag="--ignore-case"
        shift
    fi

    if [ -n "$2" ]; then
        depth_flag="--max-depth $2"
    fi

    if [ -z "$1" ]; then
        echo "Usage: fdd_exact [-i] <pattern> [max-depth]"
    else
        fd $case_flag $depth_flag --glob "$1" "$(pwd)"
    fi
}

## Nxsiv

vidt() {
    local thumb_dir="$HOME/.cache/video_thumbs"
    mkdir -p "$thumb_dir"

    # Disable confirmation for rm (using local zsh option)
    setopt localoptions rmstarsilent
    rm -f "$thumb_dir"/*

    local videos
    videos=(*.mp4(N) *.mkv(N) *.avi(N) *.mov(N) *.webm(N) *.flv(N) *.wmv(N))

    if [ ${#videos[@]} -eq 0 ]; then
        echo "No video files found in the current directory."
        return 1
    fi

    for video in "${videos[@]}"; do
        local thumbnail="$thumb_dir/${video%.*}.jpg"
        if ! ffmpegthumbnailer -i "$video" -o "$thumbnail" -s 256 2>> "$HOME/.cache/video_thumbs/errors.log"; then
            echo "Error generating thumbnail for $video"
        fi
    done

    nsxiv -t "$thumb_dir"
}

## Expressvpn Legacy

alias vpnc='sudo expressvpn connect'
alias vpnd='sudo expressvpn disconnect'
alias vpns='sudo expressvpn status'
alias vpnr='sudo expressvpn refresh'
alias vpnauto='expressvpn autoconnect true'
alias vpnset='sudo expressvpn preferences set'
alias vpnl='sudo expressvpn list'
alias vpnblock='sudo expressvpn preferences set block_all false'
alias vpnproto='sudo expressvpn protocol lightway_udp'

## Expressvpn Universal

#alias vpnc='expressvpnctl connect'
#alias vpnd='expressvpnctl disconnect'
#alias vpns='expressvpnctl status'
#alias vpnip='expressvpnctl get connectionstate && expressvpnctl get vpnip'
#alias vpndns='expressvpnctl get dnsconfigured'
#alias vpnblock='expressvpnctl set allowlan false'
#alias vpnallow='expressvpnctl set allowlan true'
#alias vpnlockon='sudo expressvpnctl set networklock true'
#alias vpnlockoff='sudo expressvpnctl set networklock false'
#alias vpnl='expressvpnctl get regions'
#alias vpntrackersoff='expressvpnctl set blockAll false'
#alias vpnproto='expressvpnctl protocol lightwayudp'
#alias vpnsplit='expressvpnctl set splittunnel true'
#alias vpnsplitskip='expressvpnctl set split-app bypass:'
#alias vpnsplitadd='expressvpnctl set split-app vpn:'
#alias vpnsplitrm='expressvpnctl set split-app remove:'

## Nvim

[ -x "$(command -v nvim)" ] && alias vim="nvim" vimdiff="nvim -d"
alias magit="nvim -c MagitOnly"

## UFW

alias ufwd='sudo ufw disable'
alias ufws='sudo ufw status'
ufwr() {
    if yes | sudo ufw reset; then :; else echo "Failed to reset ufw"; fi
    sudo ufw default deny incoming || { echo "Failed to set default deny incoming"; return 1; }
    sudo ufw default allow outgoing || { echo "Failed to set default allow outgoing"; return 1; }
    sudo ufw enable || { echo "Failed to enable ufw"; return 1; }
}

## Micro

alias sm='sudo micro'

## Bleachbit

alias bleachcache='sudo bleachbit --clean system.cache system.localizations system.trash ; sudo paccache -vrk 2 || return 0'
alias bleachchrome='bleachbit --clean chromium.cache chromium.dom thumbnails.cache'

## Garuda-update

alias garuda-refreshkeys='garuda-update remote keyring'
alias garuda-reinstallallpkgs='garuda-update remote reinstall'
alias garuda-resetaudio='garuda-update reset-audio'
alias garuda-ffmpegupdate='/Nas/Build/git/syncing/scr/installers/ffmpeg/custom_garuda_update.sh'

## Dracut

#### This will pipe to sh to execute: "dracutk | sh"
alias dracutzen='echo "sudo dracut --force --kver=$(uname -r) /boot/initramfs-linux-zen.img --enhanced-cpio --early-microcode --fstab && sudo grub-install && sudo grub-mkconfig -o /boot/grub/grub.cfg"'
alias dracutfallback='echo "sudo dracut --force /boot/initramfs-linux-fallback.img --enhanced-cpio --early-microcode --fstab && sudo grub-install && sudo grub-mkconfig -o /boot/grub/grub.cfg"'

## SSH

alias ssha='eval $(ssh-agent -s) && ssh-add'
alias sshid='xclip -sel clip < ~/.ssh/id_ed25519.pub'
#alias cleanssh="sed -i 18d .ssh/known_hosts"

## NTP

alias restartntp='sudo systemctl stop ntpd.service && sudo pacman -Syu ntp'
alias fixntp='sudo ntpd -qg && sleep 10 && sudo hwclock -w'

## Clipboard

alias paste='wl-paste'
alias copy='wl-copy <'
#paste_cmd() {
#    wl-paste | "$@"
#}
#copy_cmd() {
#    "$@" | wl-copy
#}
#alias copy='wl-copy <'

## BTRFS

alias btrfsfs='sudo btrfs filesystem df /'
alias btrfsli='sudo btrfs su li / -t'

## Snapper

alias snapcroot="sudo snapper -c root create-config /"
alias snapchome="sudo snapper -c home create-config /home"
alias snapli="sudo snapper list"
alias snapcr="sudo snapper -c root create"
alias snapch="sudo snapper -c home create"

## Oh My ZSH

#alias oz="svim ~/.zshrc"
#alias oc="cd ~/.oh-my-zsh/custom/"
#alias omzp="echo -e '\033[1;36mPlugins:\033[0m'; awk -F'=' '/^plugins/{gsub(/[\(\)]/, \"\"); split(\$2, a, \" \"); for(i in a) print a[i]}' ~/.zshrc"
#alias omzl='omz plugin list'
#alias omzi='omz plugin info'

## Network:
alias restartnetwork='sudo systemctl restart NetworkManager'
alias restartnetwork2='sudo ip link set down enp2s0 && sudo ip link set up enp2s0'
fixresolv() {
    sudo chattr -i /etc/resolv.conf
    echo -e "nameserver ::1
nameserver 127.0.0.1
options edns0 single-request-reopen" | sudo tee /etc/resolv.conf
    sudo chattr +i /etc/resolv.conf
}

### List traffic on :80
allports() {
    local output
    if output=$(ss -nat 2>/dev/null); then
        :
    else
        output=$(netstat -nat 2>/dev/null)
    fi
    echo "$output" | grep -E ":80[^0-9]" | wc -l
}
### List 20 awk conn :80
httpports() {
    sudo tcpdump -i eth0 -tnn dst port 80 -c 1000 | awk -F"." '{print $1"."$2"."$3"."$4}' | sort | uniq -c | sort -nr | head -n 20
}
### List 20 syn conn :80
synports() {
    local output
    if output=$(ss -an 2>/dev/null | awk '/SYN/ {print $5}'); then
        :
    else
        output=$(netstat -an 2>/dev/null | awk '/SYN/ {print $5}')
    fi
    echo "$output" | awk -F: '{print $1}' | sort | uniq -c | sort -nr | head -n 20
}
### List 100 conn sorted: uptime, instance sum
consume100() {
  awk '($NF > 60 && $7~/\.php/){print $7}' "$(retlog)" | sort -n | uniq -c | sort -nr | head -n 100
  # if django website or other website make by no suffix language
  # awk '{print $7}' "$(retlog)" | sort -n | uniq -c | sort -nr | head -n 100
}

# Python

### Invoke without virtual environment:
syspip() {
    PIP_REQUIRE_VIRTUALENV="" pip "$@"
}
syspip2() {
    PIP_REQUIRE_VIRTUALENV="" pip2 "$@"
}
syspip3() {
    PIP_REQUIRE_VIRTUALENV="" pip3 "$@"
}

## Virtualenv

alias pyvenv='source $XDG_DATA_HOME/virtualenv/bin/activate --prompt 💀'
alias pyvenvcd='source $XDG_DATA_HOME/virtualenv/bin/activate --prompt 💀 && cd $XDG_DATA_HOME/virtualenv'

## Pyfiglet:

figletbanner() {
    if [[ "$1" == "--help" || "$1" == "-h" ]]; then
        echo "Usage: figletc \"your text here\""
        echo "Generates stylized text using pyfiglet with line_blocks font and cyan color."
        return
    fi

    if ! command -v pyfiglet >/dev/null 2>&1; then
        echo "Error: pyfiglet is not installed. Please install it using pip:"
        echo "       pip install pyfiglet"
        return 1
    fi

    if ! command -v lolcat >/dev/null 2>&1; then
        echo "Error: lolcat is not installed. Please install it using your package manager:"
        echo "       sudo pacman -S lolcat"
        return 1
    fi

    pyfiglet --font=line_blocks --normalize-surrounding-newlines "$@" | lolcat -F 0.5
}

# Multimedia

## W3M

alias w3m='w3m https://yandex.com'

## Wget

alias imgscrape='wget -r -l1 --no-parent -nH -nd -P/tmp -A".gif,.jpg,.png" http://example.com/images'
alias mirrorsite='wget -m -k -K -E -e robots=off'

## Transmission

alias trem='transmission-remote'

## Youtube-Viewer

alias ytt='yt --skip-download --write-thumbnail'
alias YT='youtube-viewer'
alias yta='yt -x -f bestaudio/best'

## Mpv

#### For use with the MpvSockets module
alias mpv='mpv --input-ipc-server=/tmp/mpvSockets/socket1'

playdir() {
    # Set directory (default to current directory)
    dir="${1:-.}"

    # Validate that the directory exists
    if [ ! -d "$dir" ]; then
        echo "Error: Directory '$dir' does not exist."
        return 1
    fi

    # Generate playlist only with playable media files
    find "$dir" -maxdepth 1 -type f \( \
        -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" -o -iname "*.flv" -o \
        -iname "*.mov" -o -iname "*.webm" -o -iname "*.mp3" -o -iname "*.wav" -o \
        -iname "*.flac" -o -iname "*.ogg" -o -iname "*.m4a" \
    \) > dirplaylist.txt

    # Ensure the playlist is not empty
    if [ ! -s dirplaylist.txt ]; then
        echo "No playable files found in '$dir'."
        rm -f dirplaylist.txt
        return 1
    fi

    # Play with MPV, cleanup playlist after exit or error
    if command -v mpv >/dev/null 2>&1; then
        mpv --playlist=dirplaylist.txt --shuffle=yes --loop=no
    else
        echo "Error: mpv is not installed."
    fi

    # Ensure cleanup of playlist file
    rm -f dirplaylist.txt
}

#playdir() {
#    \ls $PWD > dirplaylist.txt
#    mpv --playlist=dirplaylist.txt --shuffle=yes --loop=no || rm dirplaylist.txt
#}
#alias mpvplaylist='mpv --input-ipc-server=/tmp/mpvsocket --playlist=/home/andro/mpv_playlist.txt'

## Yt-dlp

#ytdl() {
#  yt-dlp --add-metadata \
#         --embed-metadata \
#         --external-downloader aria2c \
#         --external-downloader-args "-c -j 3 -x 3 -s 3 -k 1M" \
#         -f "315/313/308/303/302/247/244/137+bestaudio/best" \
#         --merge-output-format webm \
#         --no-playlist \
#         --no-mtime \
#         "$@"
#}

#ytf() {
#    local url="$1"
#    yt-dlp --list-formats \
#           "$url"
#}

#ytp() {
#  yt-dlp --add-metadata \
#         --embed-metadata \
#         --external-downloader aria2c \
#         --external-downloader-args "-c -j 3 -x 3 -s 3 -k 1M" \
#         -f "315/313/308/303/302/247/244/137+bestaudio/best" \
#         --yes-playlist \
#    --write-playlist-metafiles \
#    --concat-playlist always \
#         "$@"
#}

## Redgifs

reddl() {
    yt-dlp --external-downloader aria2c \
           --external-downloader-args "-c -j 3 -x 3 -s 3 -k 1M" \
           -o "/home/andro/Downloads/%(title)s.%(ext)s" \
           "$@"
}

## N-m3u8-dl

m3dl() {
    local url="$1"
    local save_dir="/storage/Downloads"
    local base_name="m3dl_download"
    local extension=".mp4"
    local counter=1

    while [ -e "${save_dir}/${base_name}_${counter}${extension}" ]; do
        counter=$((counter + 1))
    done

    local save_name="${save_dir}/${base_name}_${counter}${extension}"

    \n-m3u8dl-re "$url" \
                --save-name "$save_name" \
                --use-ffmpeg-concat-demuxer \
                --thread-count 32 \
                --download-retry-count 5 \
                --auto-select \
                --live-real-time-merge \
                --mux-after-done format=mp4:muxer=ffmpeg:keep=false \
                --tmp-dir "/storage/tmp" \
                --save-dir "$save_dir" \
                --log-level INFO \
                -H "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0" \
                -H "Referer: https://example.com" \
                -H "Cookie: sessionid=abc123; other_cookie=value"
}

# Package Management

## Pkglist

alias bigpkg="expac -H M '%m\t%n' | sort -h | nl"
alias rip="expac --timefmt='%Y-%m-%d %T' '%l\t%n %v' | sort | tail -200 | nl"
alias riplong="expac --timefmt='%Y-%m-%d %T' '%l\t%n %v' | sort | tail -3000 | nl"
alias gitpkg="pacman -Q | grep -i '\-git' | wc -l"
alias pkgbysize="expac -Q '%m - %n %v' | sort -n -r"
alias mkpkglist='\bat /tmp/pacui-ls'

## Reflector

alias mirrors='sudo reflector --latest 10 --age 2 --fastest 10 --protocol https --sort rate --save /etc/pacman.d/mirrorlist'

## Pacman:

alias fixpacman='sudo unlink /var/lib/pacman/db.lck'
alias fixpacman2='sudo unlink /var/cache/pacman/pkg/cache.lck'
alias cleanpacman="sudo find /var/cache/pacman/pkg/ -iname '*.part' -delete"
alias checkdb='sudo pacman -Dk'
alias findpkg='sudo pacman -Fyx'
alias eol='comm -23 <(pacman -Qqm | sort) <(curl https://aur.archlinux.org/packages.gz | gzip -cd | sort)'

## Yay

#alias yay='yay --builddir "/home/build" --sortby votes'
#alias yay='yay --answerdiff no --builddir "/home/build" --cleanafter --cleanmenu --sortby votes'
alias yaydeps='yay --sudoloop --refresh --singlelineresults --sysupgrade --timeupdate --verbose'
alias yayskip='yay -S --mflags --skipinteg'
alias yayow='yay -S --overwrite="*" --noconfirm'
alias trizenskip='trizen -S --skipinteg'
alias update='sudo pacman -Sy && yay -Su'
yaysearch() {
    read -r -p "Choose a search parameter (1-5): " search_param
    case $search_param in
        1) yay --singlelineresults --groups --provides --searchby name ;;
        2) yay --singlelineresults --groups --provides --searchby desc ;;
        3) yay --singlelineresults --groups --provides --searchby maintainer ;;
        4) yay --singlelineresults --groups --provides --searchby packager ;;
        5) yay --singlelineresults --groups --provides --searchby depends ;;
        *) echo "Invalid choice. Please choose a number between 1 and 5." ;;
    esac
}

## Fuckin-Do-It (fn)

alias fninstall="yay -S --needed --cleanafter --cleanmenu --devel --noconfirm --rebuild --refresh --sudoloop --sysupgrade --overwrite='*' --disable-download-timeout --pgpfetch=false --removemake --redownload --batchinstall=false --answerclean=yes --answerdiff=no --answeredit=no"
alias fnupdate='yay -Syyu --noconfirm --disable-download-timeout --removemake --rebuild --pgpfetch=false --bottomup --overwrite="*"'
alias fnremove='yay -Rddn --noconfirm'

## Pacman.conf

pacmansigoff() {
    read -r -p "Are you sure you want to disable PGP signature verification? (yes/no): " answer
    if [[ $answer == "yes" ]]; then
        if sudo cp --preserve=all -f /etc/pacman.conf /etc/pacman.conf.backup; then
            sudo sed -i '/^SigLevel/ s/Required/Never/' /etc/pacman.conf && echo "PGP signature verification bypassed."
        else
            echo "Failed to create backup. Aborting."
        fi
    else
        echo "Operation canceled."
    fi
}
alias pacmansigon="if [ -f /etc/pacman.conf.backup ]; then if sudo cp --preserve=all -f /etc/pacman.conf.backup /etc/pacman.conf; then sudo rm /etc/pacman.conf.backup && echo 'PGP signature verification restored.'; else echo 'Failed to restore the original pacman.conf. Aborting.'; fi; else echo 'Backup file not found. Cannot restore.'; fi"

## GPG

alias fixdirmngr='sudo dirmngr </dev/null'
#alias chgpg='sudo chown -R $(whoami):$(whoami) ~/.gnupg && chmod 700 ~/.gnupg && chmod 600 ~/.gnupg/*'
alias rmgpg='sudo rm -r /etc/pacman.d/gnupg'
alias fixpacmankey='sudo pacman -S archlinux-keyring && sudo pacman-key --populate'
alias fixpacmankey2='gpg-agent --homedir /etc/pacman.d/gnupg --use-standard-socket --daemon'
#alias fixgpgkey="echo 'keyring /etc/pacman.d/gnupg/pubring.gpg' >> $HOME/.gnupg/gpg.conf && sudo pacman-key --populate archlinux"
alias gpgkeyserver2="sudo gpg --keyserver hkps://keys.openpgp.org/ --search-keys user-id"
alias generate-keyserver='gpg --full-generate-key && gpg --import /usr/share/pacman/keyrings/archlinux* && gpg --recv-keys --keyserver hkp://pool.sks-keyservers.net && pacman-key --init && pacman-key --populate archlinux'

## GIT

alias g='git'
alias gstat='git status'
alias gstash='git stash --all'
alias gclear='git stash clear'
alias greset="git reset --hard"
alias gfs='git-lfs'
alias grc="git rm -f --cached . && git commit -m 'Removed cached and commited'"
gclone() {
    if [[ -z "$1" ]]; then
        echo "Error: No repository URL provided."
        echo "Usage: gclone <repository-url>"
        return 1
    fi

    repo_name=$(basename "$1" .git)

    if [[ -d "$repo_name" ]]; then
        read -p "Directory '$repo_name' already exists. Do you want to force clone into it? [y/N]: " confirm
        if [[ "$confirm" != [yY] ]]; then
            echo "Clone operation aborted."
            return 1
        else
            echo "Warning: Existing directory will be used."
        fi
    fi

    temp_dir=$(mktemp -d)
    git clone --depth 1 --filter=blob:none --bare "$1" "$temp_dir" > /dev/null 2>&1
    repo_size=$(du -sm "$temp_dir" | cut -f1)
    rm -rf "$temp_dir"

    if [[ "$repo_size" -le 25 ]]; then
        echo "Small repository detected ($repo_size MB). Performing a full clone."
        depth_flag=""
    else
        echo "Large repository detected ($repo_size MB). Performing a shallow clone with --depth 5."
        depth_flag="--depth 5"
    fi

    if git clone $depth_flag "$@"; then
        cd "$repo_name" || { echo "Error: Failed to change into directory '$repo_name'."; return 1; }
        echo "Successfully cloned and switched to '$repo_name'."

        if [[ -n "$depth_flag" ]]; then
            read -p "Would you like to fetch more history (convert to full clone)? [y/N]: " fetch_more
            if [[ "$fetch_more" == [yY] ]]; then
                git fetch --unshallow
                echo "Full history fetched."
            fi
        fi
    else
        echo "Error: Failed to clone the repository."
        return 1
    fi
}
gpush() {
    git add .
    git commit -m "$*"
    git pull
    git push
}
gcomp() {
    if ! git diff-index --quiet HEAD --; then
        # Gather information about the changes
        added=$(git status --porcelain | grep "^A" | wc -l)
        modified=$(git status --porcelain | grep "^ M" | wc -l)
        deleted=$(git status --porcelain | grep "^D" | wc -l)

        commit_message="Auto-commit: ${added} added, ${modified} modified, ${deleted} deleted"

        git add --all

        if ! git commit -m "$commit_message"; then
            echo "Error: Commit failed. Aborting."
            return 1
        fi

        if ! git pull --rebase; then
            echo "Error: Pull failed. Aborting."
            return 1
        fi

        if ! git push; then
            echo "Error: Push failed. Aborting."
            return 1
        fi

        echo "Changes committed, pulled, and pushed successfully."
        echo "Commit message: $commit_message"
    else
        echo "No changes detected. Nothing to commit."
    fi
}
gaddssh() {
    eval "$(ssh-agent -s)"
    ssh-add ~/.ssh/github
    ssh -T git@github.com
}
gsearch() {
    if command -v ag &> /dev/null; then
        git exec ag "$1"
    elif command -v rg &> /dev/null; then
        git exec rg "$1"
    else
        git exec grep -r "$1"
    fi
}
grmcache() {
    cache_dir="${XDG_CACHE_HOME:-$HOME/.cache}/git"
    if [[ -d "$cache_dir" ]]; then
        read -p "Are you sure you want to delete Git cache at $cache_dir? [y/N]: " confirm
        if [[ "$confirm" == [yY] ]]; then
            rm -rf "$cache_dir"
            echo "Git cache deleted."
        else
            echo "Git cache deletion aborted."
        fi
    else
        echo "No Git cache found at $cache_dir."
    fi
}
groot() {
    if git rev-parse --show-toplevel &> /dev/null; then
        cd "$(git rev-parse --show-toplevel)" || { echo "Error: Failed to change to Git repository root."; return 1; }
        echo "Moved to Git repository root."
    else
        echo "Error: Not inside a Git repository."
        return 1
    fi
}
gremote() {
    if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
        echo "Not a git repository. Please navigate to a git repository and try again."
        return 1
    fi

    printf "Enter your GitHub username (default: 4ndr0666): "
    read -r username
    username=${username:-"4ndr0666"}

    printf "Enter the repository name: "
    read -r repo_name

    local url="git@github.com:${username}/${repo_name}.git"

    if git remote get-url origin &> /dev/null; then
        read -p "Are you sure you want to remove the current 'origin' remote? [y/N]: " confirm
        if [[ "$confirm" != [yY] ]]; then
            echo "Remote origin removal canceled."
            return 1
        fi
        git remote remove origin
        echo "Old 'origin' remote removed."
    fi

    git remote add origin "$url"
    echo "New 'origin' remote set to $url."

    git remote -v
}
ginit() {
    local repo_name commit_msg branch_name

    git init

    printf "Enter your GitHub username (default: 4ndr0666): "
    read -r username
    username=${username:-"4ndr0666"}

    printf "Enter the name of the GitHub repository: "
    read -r repo_name

    git remote add origin "git@github.com:${username}/${repo_name}.git"

    git add .

    echo "Enter a commit message for the initial commit (default: 'Initial commit'): "
    read -r commit_msg
    commit_msg=${commit_msg:-"Initial commit"}
    git commit -m "$commit_msg"

    printf "Enter the branch name to push to (default: main): "
    read -r branch_name
    branch_name=${branch_name:-"main"}

    git push -u origin "$branch_name"
}

## I/O

cleanup_session() {
    echo "Starting session cleanup..."
    log_file="/var/log/session_cleanup.log"

    # Ensure the log file exists and is writable
    if [ ! -e "$log_file" ]; then
        sudo touch "$log_file"
        sudo chmod 666 "$log_file"
    fi

    # Define the list of processes to check and terminate
    processes=("polkit-gnome-authentication-agent-1" "xdg-desktop-portal" "other-process-1" "other-process-2")

    # Loop through each process and attempt to terminate it gracefully
    for process in "${processes[@]}"; do
        if pgrep -x "$process" > /dev/null; then
            echo "Sending SIGTERM to $process..." | tee -a "$log_file"
            sudo pkill -15 -x "$process"

            # Wait up to 5 seconds for the process to terminate
            timeout=5
            counter=0
            while pgrep -x "$process" > /dev/null && [ $counter -lt $timeout ]; do
                sleep 1
                counter=$((counter + 1))
            done

            if pgrep -x "$process" > /dev/null; then
                echo "$process did not terminate after SIGTERM. Sending SIGKILL..." | tee -a "$log_file"
                sudo pkill -9 -x "$process"
                sleep 1
                if pgrep -x "$process" > /dev/null; then
                    echo "Failed to terminate $process even after SIGKILL." | tee -a "$log_file"
                else
                    echo "$process terminated successfully after SIGKILL." | tee -a "$log_file"
                fi
            else
                echo "$process terminated gracefully." | tee -a "$log_file"
            fi
        else
            echo "$process not running." | tee -a "$log_file"
        fi
    done

    # Clear temporary files or session caches
    echo "Clearing temporary files and session caches..." | tee -a "$log_file"
    sudo rm -rf /tmp/*
    sudo rm -rf /var/tmp/*
    echo "Temporary files cleared." | tee -a "$log_file"

    # Additional cleanup for user session state or session artifacts (optional)
    echo "Removing any lingering lock files or session artifacts..." | tee -a "$log_file"
    sudo rm -f /run/user/$(id -u)/lock/*

    # Sync filesystem buffers
    echo "Syncing filesystem buffers..." | tee -a "$log_file"
    sync

    echo "Session cleanup complete." | tee -a "$log_file"
}

alias sdn="cleanup_session && echo 'Shutting down...' | sudo tee -a /var/log/user_commands.log && sudo shutdown -h now"
alias ssr="cleanup_session && echo 'Rebooting...' | sudo tee -a /var/log/user_commands.log && sudo reboot -h now"
alias magic='sudo /usr/local/bin/magic.sh'

# =================================== // 4NDR0TOOLS //

## 4ndr0cht

#### Fzf for cheat-sheets in "~/.cheaters/"
cht() {
    local cheats
    cheats=("$HOME/.cheater/"*.md)
    local choice
    choice=$(printf "%s\n" "${cheats[@]}" | fzf --prompt="Select a cheat sheet: ")
    [ -n "$choice" ] && bat --language=mdown "$choice" || echo "No cheat sheet selected."
}

## 4ndr0conf

#### modular help function
edit_config() {
    local file_path="$1"
    if [[ $file_path ]]; then
        sudo chattr -i "$file_path"
        sudo -S nvim "$file_path"
    else
        echo "File path not provided."
    fi
}

alias svim='edit_config'
alias valias='edit_config "$XDG_CONFIG_HOME"/zsh/aliasrc'
alias vfunc='edit_config "$XDG_CONFIG_HOME"/zsh/functions.zsh'
alias vpac='edit_config /etc/pacman.conf'
alias vgrub='edit_config /etc/default/grub'
alias vgrubc='edit_config /boot/grub/grub.cfg'
alias vmkinit='edit_config /etc/mkinitcpio.conf'
alias vmirror='edit_config /etc/pacman.d/mirrorlist'
alias vchaotic='edit_config /etc/pacman.d/chaotic-mirrorlist'
alias vfstab='edit_config /etc/fstab'
alias vzpro='edit_config "$XDG_CONFIG_HOME"/zsh/.zprofile'
alias vbash='edit_config "$XDG_CONFIG_HOME"/zsh/.bashrc'
alias vzsh='edit_config "$XDG_CONFIG_HOME"/zsh/.zshrc'
alias vhosts='edit_config /etc/hosts'
alias vmpv='edit_config "$XDG_CONFIG_HOME"/mpv/mpv.conf'
alias vfire='edit_config "$XDG_CONFIG_HOME"/wayfire.ini'
alias vbar='edit_config "$XDG_CONFIG_HOME"/wayfire/waybar/config'
alias vhostname='edit_config /etc/hostname'

## Directory Shortcuts

#### modular helper function
goto() {
    local dir="$1"
    if [[ -d "$dir" ]]; then
        cd "$dir" || exit
    else
        echo "Directory not found: $dir"
    fi
}

### /home:

alias dc='goto ~/Documents'
alias dl='goto ~/Downloads'
alias vid='goto ~/Videos'
alias pic='goto ~/Pictures'
alias conf='goto ~/.config'
alias wconf='goto ~/.config/wayfire'
alias zconf='goto ~/.config/zsh'
alias mconf='goto ~/.config/mpv'
alias ob='goto ~/.config/openbox'
alias obt='goto ~/.config/openbox/themes'

### /storage:

alias s1='goto /storage'
alias s1dl='goto /storage/Downloads'
alias s1pic='goto /storage/Pictures'
alias s1vid='goto /storage/Videos'
alias streamdir='goto /storage/streamlink'

### /sto2:

alias s2='goto /sto2'
alias s2dl='goto /sto2/Downloads'
alias s2pic='goto /sto2/Pictures'
alias s2vid='goto /sto2/Videos'
alias gym='goto /sto2/Gym'
alias jd='goto /sto2/JD'

### /4ndr0:

alias 4n='goto /4ndr0'

### /23.1

alias edits='goto /23.1/Edits'
alias cloud='goto /23.1/Thecloud'

### /Nas:

alias nas='goto /Nas'
alias sandbox='goto /Nas/sandbox'

### /home/git:

alias ngc='goto /home/git/clone'
alias ndot='goto /home/git/clone/dotfiles'
alias nbin='goto /home/git/clone/scr'
alias npkg='goto /Nas/Build/pkgs'

### System directories:

alias et='goto /etc'
alias ske='goto /etc/skel'
alias bin='goto /usr/local/bin'
alias loc='goto ~/.local'
alias lbin='goto ~/.local/bin'
alias cheat='goto ~/.cheater'
alias lshare='goto ~/.local/share/'
alias lsrc='goto ~/.local/src/'
alias cac='goto ~/.cache'

## 4ndr0kill

#### Uses `killal` with fzf as the file sel:
killit() {
    local pattern="$1"
    if [[ -z "$pattern" ]]; then
        echo "Error: Please provide a process name or pattern."
        return 1
    fi

    echo "Searching for processes matching '$pattern'..."
    local pids
    pids=$(pgrep -fl "$pattern")

    if [[ -z "$pids" ]]; then
        echo "No processes found matching '$pattern'."
        return 1
    fi

    echo "Found processes:"
    echo "$pids"

    echo "Please enter the PIDs to kill (separate multiple PIDs with spaces):"
    read -r pid_list

    if [[ -z "$pid_list" ]]; then
        echo "No PIDs provided, no action taken."
        return 1
    fi

    for pid in $pid_list; do
        if echo "$pids" | grep -q -w "$pid"; then
            if sudo pkill -f "$pid"; then
                echo "Process $pid killed."
            else
                echo "Failed to kill process $pid."
            fi
        else
            echo "PID $pid does not match any of the listed processes. Skipping."
        fi
    done
}

## 4ndr0view

#### Quicly view configuration files
alias 00='bat ~/.config/shellz/aliasrc'
alias 0f='bat ~/.config/shellz/functions.zsh'
alias 0z='bat ~/.config/zsh/.zshrc'
alias 0p='bat ~/.config/zsh/.zprofile'

# ===================================================================================================

#### Enter typo followed by the correction:
alias gerp='grep'
alias shudown='shutdown'
alias pdw='pwd'
alias micor='micro'
alias cpoy='copy'
alias dc='cd'
alias sl='ls'
alias car='cat'
alias nvin='nbin'
alias cay='cat'
alias reloda='reload'
