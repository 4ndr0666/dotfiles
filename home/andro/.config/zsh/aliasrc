# ALIASRC
# Author: 4ndr0666
# ===================================== // ALIASRC //
## Description: List of aliases for sourcing with zsh
# --------------------------------------

## Interactive Check

#if [[ -o interactive ]]; then
#    alias reload='exec zsh'
#    alias mkdir='mkdir -pv'
#    alias mkgpg="[ -d ~/.gnupg ] || (mkdir ~/.gnupg && cp /etc/pacman.d/gnupg/gpg.conf ~/.gnupg/ && echo 'done')"
#fi

## Ls Configs______________________________________________

### Config 1

alias ls='eza -X --no-filesize --no-time --no-permissions --colour-scale=size --colour-scale-mode=gradient --group-directories-first --icons=always --smart-group'
alias la='eza -alXMoZ --no-quotes --time=created --classify=always --colour-scale=all --colour-scale-mode=gradient --icons=always'
#'lsd -alLU --permission=rwx --color=always --group-directories-first --icon=always'
alias ll='eza -xXDh --colour-scale=size --colour-scale-mode=gradient --icons=always --smart-group'
alias l.='eza -Xd --sort new --colour-scale-mode=gradient --colour-scale=age --group-directories-first --icons=always .[!.]*'
#exa -aT -s new --color=always --group-directories-first --icons

### Config 2

#alias l='ls'
#alias ls="ls -alhfN --time-style=long-iso --color=auto --group-directories-first"
#alias ll="ls -lFh --color=auto --group-directories-first --time-style=long-iso"
#alias la='exa -hFlBgmnsa -s new --git --octal-permissions --group-directories-first --icons'
#alias lt='ls -ltFh'
#alias ldot='ls -1FSsh'
#alias lart='ls -1Fcart'
#alias lrt='ls -1Fcrt'
#alias lm='ls -m'
#alias lg='ls -l --group-directories-first'

### Config 3

#alias l.='ls -d .* --color=auto'
#alias ll='ls -lh --color=auto'
#alias la='ls -lha --color=auto'
#alias lsd='ls -lhS --color=auto | grep -E "^d"'
#alias lsf='ls -lhS --color=auto | grep -E "^-"'
#alias lsp='ls -lhS --color=auto | grep -E "^l"'

### Config 4

#alias ls='ls --group-directories-first --color'
#alias ll='ls -lhF'
#alias la='ls -lha'
#alias lt='ls -lhtr'
#alias lta='ls -lhatr'

### Config 5

#alias lm='ls | more'
#alias ll='ls -lFh --group-directories-first'
#alias la='ls -alFh --group-directories-first'
#alias l1='ls -1F --group-directories-first'
#alias l1m='ls -1F --group-directories-first | more'
#alias lh='ls -ld .??*'
#alias lsn='\ls | cat -n'

## Ls Functions_________________________________________________

### Ls by size

alias lss='lsd -FhSr'

### Ls by Extension

alias lse='eza -Xh --sort=extension --no-filesize --no-time --no-permissions --colour=auto --colour-scale=size --colour-scale-mode=gradient --group-directories-first --icons=always --smart-group'

### Ls by Name

alias lsn='eza -Xh --sort=name --no-filesize --no-time --no-permissions --colour=auto --colour-scale=size --colour-scale-mode=gradient --group-directories-first --icons=always --smart-group'

### Ls files only

alias lsf='eza -xrf --colour=always --colour-scale=age --colour-scale-mode=gradient --icons=always'

### Ls Most Recent Files Last

alias lr='lsd -tr'
#eza -XGx --no-filesize --no-permissions --no-user --sort modified --group-directories-first --icons=always --colour-scale=age --colour-scale-mode=gradient'

### List All Modified Files in Past 60 min

alias ls60='sudo find / -mmin 60 -type f'

### List Files & Dirs Modified in Past Day

alias lsfdday='\ls *(m0)'

### List Files Modified in Past Day

alias lsfday='\ls *(.m0)'

### List 10 Newest

alias lsnew='\ls *(.om[1,10])'

### List Most Recent Subdir

alias lssubdir='\ls -d *(/om[1])'

### Unknown

alias LS='\ls -1FSsh'

### Ls with Bat

alias lb='\ls | bat'

### Ls on One Line

alias l1='lsd -1'

### Ls symlinks

alias lta='\ls -ltrha'

## Login Manager

alias tolightdm="sudo pacman -S lightdm lightdm-gtk-greeter lightdm-gtk-greeter-settings --noconfirm --needed ; sudo systemctl enable lightdm.service -f ; echo 'Lightdm is active - reboot now'"
alias tosddm="sudo pacman -S sddm --noconfirm --needed ; sudo systemctl enable sddm.service -f ; echo 'Sddm is active - reboot now'"
alias toly="sudo pacman -S ly --noconfirm --needed ; sudo systemctl enable ly.service -f ; echo 'Ly is active - reboot now'"
alias togdm="sudo pacman -S gdm --noconfirm --needed ; sudo systemctl enable gdm.service -f ; echo 'Gdm is active - reboot now'"
alias tolxdm="sudo pacman -S lxdm --noconfirm --needed ; sudo systemctl enable lxdm.service -f ; echo 'Lxdm is active - reboot now'"

## Shell

alias tobash="sudo chsh $USER -s /bin/bash && echo 'Now log out.'"
alias tozsh="sudo chsh $USER -s /bin/zsh && echo 'Now log out.'"
alias tofish="sudo chsh $USER -s /bin/fish && echo 'Now log out.'"

## Refresh Deps

### Wayfire

alias refreshwayfire='yay -Syyu wayfire-git wlroots-git xorg-xwayland extra-cmake-modules-git light pastel python-pywall playerctl xdg-desktop-portal xdg-desktop-portal-wlr --noconfirm --rebuildtree --redownloadall --overwrite="*"'

#alias refreshwayfire='yay -Syyu egl-wayland-git wayfire-git wf-config-git wf-recorder-git wayland-git git wayland-protocols-git wayland-utils-git qt5-wayland qt6-wayland wlroots-git wlr-protocols-git --noconfirm --rebuildtree --overwrite="*" --sudoloop'

#function refreshwayfire() {
#	sudo pacman -Rns archcraft-wayfire wayfire-git wayfire-plugins-extra-git wf-config-git wf-recorder-git
#	git clone https://github.com/WayfireWM/wayfire.git
#	cd wayfire
#	meson setup build --prefix=/usr
#	ninja -C build
#	sudo ninja -C build install
#	cd ..
#	git clone https://github.com/WayfireWM/wf-config.git
#	cd wf-config
#	meson setup build --prefix=/usr
#	ninja -C build
#	sudo ninja -C build install
#	yay -S wayfire-plugins-extra-git wf-recorder-git --rebuildtree --redownloadall --noconfirm
#}

### Graphics
alias refreshgraphics='yay -Syyu --needed mesa mesa-utils mesa-demos vulkan-radeon vulkan-mesa-layers lib32-vulkan-radeon lib32-vulkan-mesa-layers vulkan-tools libva-utils mesa-vdpau libva-mesa-driver xf86-video-amdgpu xf86-video-ati linux-firmware wayfire-git wayland-git wlroots-git gtk3 dbus polkit greetd greetd-gtkgreet libdrm libxxf86vm libxdamage libxshmfence libelf libomxil-bellagio libunwind egl-wayland-git lib32-egl-wayland-git libglvnd libvdpau clinfo libclc opencl-mesa libxpresent libxrandr libxcomposite libxinerama libxext --noconfirm --overwrite="*" --rebuildtree --redownloadall --sudoloop'

### HDD Exec
alias refreshexec='sudo mount -o remount,exec /boot/efi && sudo mount -o remount,exec /home && sudo mount -o remount,exec /'

## System General Aliases___________________________________

alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
alias ......='cd ../../../../..'
alias s='sudo'
alias e='$EDITOR'
alias v='$EDITOR'
alias p="sudo pacman"
alias ka='sudo killall -9'
alias cp='cp --preserve=all'
alias cpp='rsync -ahzXW --info=progress2'
alias mv='mv -iv'
alias rm='rm -vI'
alias bc='bc -l'
alias rmf='sudo -S /bin/rm -vI -rf'
alias rmd='sudo -S /bin/rm  --recursive --force --verbose '
alias rg="rg --sort path"
function diff() {
  if [[ "$1" == "-y" ]]; then
    colordiff "$@"
  else
    command diff "$@"
  fi
}
alias rmdir='\rm -vI --preserve root'
alias ln='ln -iv'
alias wget="wget -c"
alias curl="curl --user-agent 'noleak'"
alias df='df -h --exclude-type=squashfs --exclude-type=tmpfs --exclude-type=devtmpfs'
#alias cat='bat --paging=never'
alias ccat="highlight --out-format=ansi"
alias showpath='echo $PATH | tr ":" "\n"'
alias rsync='rsync -vrPlu'
alias unhblock='hblock -S none -D none'
alias grep='grep --color=auto'
alias grepc='grep --color=always'
alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'
alias c='clear; echo; echo; seq 1 $(tput cols) | sort -R | spark | lolcat; echo; echo'
#clear; seq 1 $(tput cols) | sort -R | sparklines | lolcat
alias hw='sudo hwinfo --short'
alias lsb='lsblk -o NAME,FSTYPE,SIZE,MOUNTPOINT'
alias jctl='journalctl -p 3 -xb'
alias mapit="ifconfig -a | grep -Po '\b(?!255)(?:\d{1,3}\.){3}(?!255)\d{1,3}\b' | xargs nmap -A -p0-"
alias ports='ss -tunlp'
alias whatsonline='lsof -P -i -n'
alias speedtest='curl -s https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.py | python3 -'
alias netspeed='ifstat -t -S -w'
alias dir5='du -cksh * | sort -hr | head -5'
alias dir10='du -cksh * | sort -hr | head -10'
alias dir='dir --color=auto'
alias mem10='ps aux | sort -nk +4 | tail'
alias pacdiff='sudo -H DIFFPROG=meld pacdiff'
alias psgrep="ps aux | grep -v grep | grep -i -e VSZ -e"
alias myip='curl canhazip.com'
alias mybios='dmidecode -t bios'

## System General Functions_________________________________

mktest() {
    mkdir -p tests/{Pictures,Media,Documents,Archives} && \
    echo "Dummy image content" > tests/Pictures/test.jpg && \
    echo "Dummy audio content" > tests/Media/test.mp3 && \
    echo "Dummy document content" > tests/Documents/test.pdf && \
    echo "Dummy text content" > tests/test.txt && \
    echo "Dummy PNG content" > tests/test.png && \
    zip -j tests/Archives/test.zip tests/Documents/test.pdf >/dev/null && \
    tar -czf tests/Archives/test.tar.gz -C tests/Documents test.pdf && \
    echo "Dummy archive content" > tests/Archives/dummy_content.txt && \
    7z a -bd -y tests/Archives/test.7z tests/Archives/dummy_content.txt >/dev/null && \
    rar a -idq tests/Archives/test.rar tests/Archives/dummy_content.txt >/dev/null && \
    tar -cf tests/Archives/test.tar -C tests/Archives dummy_content.txt
}

### Gather total number of files

filecount() {
    if [[ "$1" == "-l" ]]; then
        echo "Files in $PWD:"
        find "$PWD" -type f
    else
        echo "Total files in $PWD: $(find "$PWD" -type f | wc -l)"
    fi
}

lsmount() {
    if [[ -n "$1" ]]; then
        mount | column -t | grep "$1"
    else
        mount | column -t
    fi
}

### Aggregate Pkgs Deps

whatdependson() {
    local search="$1"
    sudo pacman -Sii "$search" | grep "Required" | sed -e "s/Required By     : //g" | sed -e "s/  /\n/g"
}

### Custom find cmd

findit() {
    if [[ -n "$1" ]]; then
        find . -type f -printf "%TY%Tm%Td\t%p\n" | sort | grep -i "$1"
    else
        return 1
    fi
}

### Backup files in the $PWD

archive() {
    local target="$1"
    local backup_dir="${2:-$PWD}"
    sudo mkdir -p "$backup_dir"

    if [[ -z "$target" ]]; then
        echo "Error: Please provide a file or directory to back up."
        return 1
    fi

    if [[ ! -e "$target" ]]; then
        echo "Error: The target '$target' does not exist."
        return 1
    fi

    local target_name
    target_name=$(basename "$target")
    local timestamp
    timestamp=$(date -u "+%h-%d-%Y_%H.%M%p")
    local backup_file="${backup_dir}/${target_name}_backup-${timestamp}.tar.gz"

    echo "Creating backup for '$target'..."

    ### Check if we have write access to the backup directory and read access to the target
    if [[ ! -w "$backup_dir" || ! -r "$target" ]]; then
        echo "Insufficient permissions, attempting with sudo..."
        if sudo tar -czvf "$backup_file" "$target"; then
            echo "Backup successful with sudo: $backup_file"
        else
            echo "Error: Failed to create backup with sudo."
            return 1
        fi
    else
        if sudo tar -czvf "$backup_file" "$target"; then
            echo "Backup successful: $backup_file"
        else
            echo "Error: Failed to create backup."
            return 1
        fi
    fi
}

### Shortcut for tar archives

tarnow() {
    local target="$1"
    local backup_dir="${2:-.}"

    if [[ -z "$target" ]]; then
        echo "Provide dir to tarball."
        return 1
    fi

    if [[ ! -e "$target" ]]; then
        echo "Error: The target '$target' does not exist."
        return 1
    fi

    local target_name
    target_name=$(basename "$target")
    local timestamp
    timestamp=$(date -u "+%m-%d_%I:%M%p")
    local backup_file="${backup_dir}/${target_name}-${timestamp}.tar.gz"

    echo "Creating tarball for '$target'..."

    ### Check if we have write access to the backup directory and read access to the target
    if [[ ! -w "$backup_dir" || ! -r "$target" ]]; then
        echo "Bypassed: permissions."
        if sudo tar -czvf "$backup_file" "$target"; then
            echo "Tarball successful: $backup_file"
        else
            echo "Error: permissions."
            return 1
        fi
    else
        if sudo tar -czvf "$backup_file" "$target"; then
            echo "Tarball: $backup_file"
        else
            echo "Error: Failed to compress tarball."
            return 1
        fi
    fi
}

alias untar='sudo tar xvf'

### Custom Delete

rmshred() {
    if [ -z "$1" ]; then
        echo "Usage: rmshred <directory>"
        return 1
    fi
    if [ ! -d "$1" ]; then
        echo "Error: '$1' is not a directory"
        return 1
    fi

    echo -n "Are you sure you want to swiftly delete '$1'? (y/N) "
    read confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo "Aborted."
        return 1
    fi

    ### Count the total number of files for progress estimation.
#    total_files=$(find "$1" -type f | wc -l)
#    echo "Deleting ${total_files} files in '$1'..."

    ### Delete files using GNU Parallel with a progress bar.
    sudo find "$1" -type f -print0 | parallel -0 -n 100 rm -f

    ### Remove directories after files have been deleted.
    sudo find "$1" -depth -type d -exec rmdir {} \; > /dev/null 2>&1

    ### Finally, remove the top-level directory.
    sudo rm -rf "$1" > /dev/null 2>&1

    echo "Deletion completed for '$1'."
}

psmem() {
    local count="${1:-5}"
    echo "Top $count memory-consuming processes:"
    if ! ps aux --sort=-%mem | awk 'NR==1; NR>1 {print $0}' | head -n $((count + 1)); then
        echo "Error retrieving memory info."
        return 1
    fi
}

pscpu() {
    local count="${1:-5}"
    echo "Top $count CPU-consuming processes:"
    if ! ps aux --sort=-%cpu | awk 'NR==1; NR>1 {print $0}' | head -n $((count + 1)); then
        echo "Error retrieving CPU info."
        return 1
    fi
}

### Delete all 0 byte folders

d0() {
    local target_dir="${1:-.}"
    find "$target_dir" -type f -size 0 -print0 | while IFS= read -r -d '' file; do
        read -r -p "Delete '$file'? [y/N] " response
        if [[ $response =~ ^[Yy]$ ]]; then
            rm -rf "$file"
            echo "Deleted: $file"
        else
            echo "Skipped: $file"
        fi
    done
}

## Xorg Display____________________________________________

alias xd='ls /usr/share/xsessions'
alias xdw="ls /usr/share/wayland-sessions"
alias xfix='echo "DISPLAY=:0 XAUTHORITY=$HOME/.Xauthority xterm"'
alias xi='sudo xbps-install'
alias xr='sudo xbps-remove -R'
alias xq='xbps-query'
alias xmerge='xrdb -merge ~/.Xresources'

## Permissions________________________________________________

## Chmod

alias chown='sudo chown --preserve-root'
alias chmod='sudo chmod --preserve-root'
alias chgrp='sudo chgrp --preserve-root'
alias lck='sudo chattr +i '
alias ulck='sudo chattr -i '
alias chgpg='sudo chown -R $USER:$USER ~/.gnupg && sudo chmod 700 ~/.gnupg && sudo chmod 600 ~/.gnupg/*'
alias chtmp='sudo chown root:root /tmp && sudo chmod 1777 /tmp && sudo mount -o remount,exec /tmp'
alias chlocal='sudo chown -R $USER:$USER ~/.config ~/.local && echo "Ownership of ~/.config and ~/.local changed to $USER."'
alias chnpm='sudo chown -R 1000:1000 /home/andro/.npm'
alias rmx='find . -type f -exec chmod -x {} \;'

chpython() {
    local python_version
    python_version=$(python3 -c 'import sys; print(".".join(map(str, sys.version_info[:2])))')

    local site_packages_dir="/usr/lib/python${python_version}/site-packages"

    if [[ -d "$site_packages_dir" ]]; then
        echo "Setting ownership to root and permissions to 755 for: $site_packages_dir"
        if ! sudo chown -R root:root "$site_packages_dir"; then
            echo "Error: Failed to change ownership for $site_packages_dir."
            return 1
        fi
        if ! sudo chmod -R 755 "$site_packages_dir"; then
            echo "Error: Failed to set permissions for $site_packages_dir."
            return 1
        fi
        echo "Ownership and permissions set successfully for $site_packages_dir."
    else
        echo "Error: Directory $site_packages_dir not found for Python version $python_version."
    fi
}

chboot() {
    if ! sudo chmod -R 755 /boot/efi; then
        echo "Error: Failed to chmod /boot/efi."
        return 1
    fi
    if ! sudo chown -R root:root /boot/efi; then
        echo "Error: Failed to chown /boot/efi."
        return 1
    fi
    echo "Boot directory permissions reset appropriately."
}

chdirs() {
    if [[ -z "$1" ]]; then
        echo "Usage: chdirs <directory_path>"
        return 1
    elif [[ ! -d "$1" ]]; then
        echo "Error: '$1' is not a valid directory."
        return 1
    fi

    local target_dir="$1"
    echo "Setting permissions: U+rwx | G+rwx | O+rx for all directories in '$target_dir'..."

    if ! sudo find "$target_dir" -type d -exec chmod 755 {} +; then
        echo "Error: Failed to set permissions for directories in '$target_dir'."
        return 1
    fi

    echo "‚úîÔ∏è All dirs in '$target_dir' set to 755."
}

chfd() {
    if [[ -z "$1" ]]; then
        echo "Usage: chfdirs <file_or_dir_path>"
        return 1
    fi

    local target="$1"

    if [[ -f "$target" ]]; then
        # If it's a file, apply chmod 664
        echo "Setting permissions: U+rwx | G+rx | O+rx for file '$target'..."
        if ! sudo chmod 664 "$target"; then
            echo "Error: Failed to set permissions for file '$target'."
            return 1
        fi
    elif [[ -d "$target" ]]; then
        # If it's a directory, apply chmod 774 recursively
        echo "Setting permissions: U+rwx | G+rx | O+rx for all files in directory '$target'..."
        if ! sudo find "$target" -type f -exec chmod 774 {} +; then
            echo "Error: Failed to set permissions for files in directory '$target'."
            return 1
        fi
    else
        echo "Error: '$target' is not a valid file or directory."
        return 1
    fi

    echo "‚úîÔ∏è Successfully set permissions to 774 for '$target'."
}

chandro() {
    if [[ -z "${1:-}" ]]; then
        echo "Usage: chandro [-R] <file_or_dir_path>"
        return 1
    fi

    local recursive=false
    if [[ "$1" == "-R" || "$1" == "-r" ]]; then
        recursive=true
        shift
    fi

    local target="${1:-}"
    if [[ -z "$target" ]]; then
        echo "Error: No file or directory specified."
        return 1
    fi
    if [[ ! -e "$target" ]]; then
        echo "Error: '$target' does not exist."
        return 1
    fi

    echo "Setting ownership to 'andro:andro' and permissions (files: 664, dirs: 774) for '$target'..."

    if $recursive; then
        if ! sudo chown -R andro:andro "$target"; then
            echo "Error: Failed to change ownership for '$target'."
            return 1
        fi
        # Set dir to 774, file to 664, recursively
        if ! sudo find "$target" -type d -exec chmod 774 {} +; then
            echo "Error: Failed to set directory permissions."
            return 1
        fi
        if ! sudo find "$target" -type f -exec chmod 664 {} +; then
            echo "Error: Failed to set file permissions."
            return 1
        fi
    else
        if ! sudo chown andro:andro "$target"; then
            echo "Error: Failed to change ownership for '$target'."
            return 1
        fi
        if [[ -d "$target" ]]; then
            if ! sudo chmod 774 "$target"; then
                echo "Error: Failed to set directory permissions."
                return 1
            fi
        else
            if ! sudo chmod 664 "$target"; then
                echo "Error: Failed to set file permissions."
                return 1
            fi
        fi
    fi
    echo "‚úîÔ∏è Successfully set ownership and permissions for '$target'."
}

#chandro() {
#    if [[ -z "$1" ]]; then
#        echo "Usage: chandro [-R] <file_or_dir_path>"
#        return 1
#    fi
#    # Check if recursive flag is provided
#    local recursive=false
#    if [[ "$1" == "-R" ]]; then
#        recursive=true
#        shift
#    fi
#
#    local target="$1"
#    if [[ -z "$target" ]]; then
#        echo "Error: No file or directory specified."
#        return 1
#    fi
#
#    if [[ ! -e "$target" ]]; then
#        echo "Error: '$target' does not exist."
#        return 1
#    fi
#    echo "Setting ownership to 'andro:andro' and permissions to 664 for '$target'..."
#    # Apply ownership and permissions
#    if [[ "$recursive" == true ]]; then
#        if ! sudo chown -R andro:andro "$target"; then
#            echo "Error: Failed to change ownership for '$target'."
#            return 1
#        fi
#        if ! sudo chmod -R 664 "$target"; then
#            echo "Error: Failed to set permissions for '$target'."
#            return 1
#        fi
#    else
#        if ! sudo chown andro:andro "$target"; then
#            echo "Error: Failed to change ownership for '$target'."
#            return 1
#        fi
#        if ! sudo chmod 664 "$target"; then
#            echo "Error: Failed to set permissions for '$target'."
#            return 1
#        fi
#    fi
#    echo "‚úîÔ∏è Successfully set ownership and permissions for '$target'."
#}

chrootuser() {
    if [[ -z "$1" ]]; then
        echo "Usage: chrootuser [-R] <file_or_dir_path>"
        return 1
    fi

    ### Check if recursive flag is provided
    local recursive=false
    if [[ "$1" == "-R" ]]; then
        recursive=true
        shift
    fi

    local target="$1"

    if [[ -z "$target" ]]; then
        echo "Error: No file or directory specified."
        return 1
    fi

    if [[ ! -e "$target" ]]; then
        echo "Error: '$target' does not exist."
        return 1
    fi

    echo "Setting ownership to 'root:root' and adjusting permissions for '$target'..."

    ### Apply ownership and permissions
    if [[ "$recursive" == true ]]; then
        if ! sudo chown -R root:root "$target"; then
            echo "Error: Failed to change ownership for '$target'."
            return 1
        fi
        if ! sudo find "$target" -type d -exec chmod 755 {} +; then
            echo "Error: Failed to set directory permissions for '$target'."
            return 1
        fi
        if ! sudo find "$target" -type f -exec chmod 644 {} +; then
            echo "Error: Failed to set file permissions for '$target'."
            return 1
        fi
    else
        if ! sudo chown root:root "$target"; then
            echo "Error: Failed to change ownership for '$target'."
            return 1
        fi

        ### Set permissions based on type
        if [[ -d "$target" ]]; then
            if ! sudo chmod 755 "$target"; then
                echo "Error: Failed to set permissions for '$target'."
                return 1
            fi
        elif [[ -f "$target" ]]; then
            if ! sudo chmod 644 "$target"; then
                echo "Error: Failed to set permissions for '$target'."
                return 1
            fi
        fi
    fi

    echo "‚úîÔ∏è Successfully set ownership and permissions for '$target'."
}

## System Admin & Maintenance____________________________________________________________

alias update-grub2='sudo grub-install ... && sudo grub-mkconfig -o /boot/grub/grub.cfg'
#alias grub-mkconfig='sudo grub-mkconfig -o /boot/grub/grub.cfg'
alias iotop='sudo iotop -o'
alias pathadd='export PATH=/home/andro/.local/bin:/home/git/clone/4ndr0666/scr:$PATH'
alias whatkernel="ls /usr/lib/modules"
alias whatsrunning='systemctl -t service -a --state running --no-page --no-legend'
alias fixnvm='nvm use --delete-prefix v22.13.0 --silent'
alias fixnode='npm audit fix --force'
alias fixkeyboard='sudo localectl set-x11-keymap us'
alias listusers='cut -d: -f1 /etc/passwd | sort'
alias fixlocales='sudo localectl set-locale LANG=en_US.UTF-8'
alias microcode='grep . /sys/devices/system/cpu/vulnerabilities/*'
alias audio="pactl info | grep 'Server Name'"
alias retry='until !!; do :; done'
alias whatcpu="grep -m1 'model name' /proc/cpuinfo"
alias kp='sudo killall -9 xdg-desktop-portal xdg-desktop-portal-gtk xdg-desktop-portal-wlr'

## Backup and restore /etc/skel

#alias bupskel='sudo cp -Rf /etc/skel /var/recover/skel-backup-$(date +"%Y.%m.%d-%H.%M.%S") && echo "Backup of skel made."'
#alias restoreskel='sudo cp -Rf /var/recover/skel-backup-*/. $HOME/ && echo "Restored from latest backup."'

## Copy rc files from /etc/skel

#alias cb='cp /etc/skel/.bashrc ~/.bashrc && exec bash'
#alias cz='cp /etc/skel/.zshrc ~/.zshrc && echo "Copied."'
#alias cf='cp /etc/skel/.config/fish/config.fish ~/.config/fish/config.fish && echo "Copied."'

#fixo() {
#  [[ -d "$1" ]] &&
#    find "$1" -type d -print0 | xargs -0 chmod 755 && find "$1" -type f -print0 | xargs -0 chmod 644 ||
#    echo "$1 is not a directory."
#}
#fix() {
#  [[ -d "$1" ]] &&
#    find "$1" -type d -print0 | xargs -0 chmod 750 && find "$1" -type f -print0 | xargs -0 chmod 640 ||
#    echo "$1 is not a directory."
#}
#fixp() {
#  [[ -d "$1" ]] &&
#    find "$1" -type d -print0 | xargs -0 chmod 700 && find "$1" -type f -print0 | xargs -0 chmod 600 ||
#    echo "$1 is not a directory."
#}

## Program Specific__________________________________________________________________________________

### Zathura
alias z='zathura --fork'

### Bat
### Instead of `cmd --help` do `help cmd`:

alias bathelp='bat --plain --language=help'

help() {
    "$@" --help >/dev/null 2>&1 || "$@" -h >/dev/null 2>&1 | bathelp
}

alias man='batman'

### Parses git syntax

batdiff() {
    git diff --name-only --relative --diff-filter=d | xargs bat --diff
}

### Pipe to less

alias batl='bat | less'

## Lf

alias lf='lfub'
alias ref='shortcuts >/dev/null; source ${XDG_CONFIG_HOME:-$HOME/.config}/shellz/shortcutrc; source ${XDG_CONFIG_HOME:-$HOME/.config}/shellz/shortcutenvrc; source ${XDG_CONFIG_HOME:-$HOME/.config}/shellz/zshnameddirrc'

## Wf-recorder

#alias screenrecord="wf-recorder -a"
#alias screenrecord2="wf-recorder -a -c h264_vaapi -C aac -d /dev/dri/renderD128 --file=recording.mp4"

## FZF

### Select files from dir and edit

fzscr() {
    local dir="${1:-/home/git/clone/4ndr0666/scr}"
    local choice
    choice=$(find "$dir" -mindepth 1 \( -type d -o -executable -type f \) \
        ! -path '*/.git/*' -printf '%P\n' | sort -r | fzf --preview "cat '$dir/{}'" --preview-window=down:70%)
    if [ -n "$choice" ]; then
        if [ -d "$dir/$choice" ]; then
            echo "Selected directory: $dir/$choice"
        elif [ -x "$dir/$choice" ]; then
            echo "Executing $dir/$choice ..."
            "$dir/$choice"
        else
            echo "No script selected or script is not executable."
        fi
    else
        echo "No selection made."
    fi
}

## Kmon

alias kmon='sudo kmon --color blue --accent-color 15FFFF --unicode'

## The Silver Searcher

ags() {
    if [ "$#" -ne 2 ]; then
        echo "Usage: ags <filename> <search_term>"
        return 1
    fi
    ag --group --stats --color "$2" "$1" | less -R
}

## FD

### Fd plus hidden minus .git

alias fd='fd --hidden --follow --exclude ".git"'

### Fd plus hidden

alias fdh='fd --hidden --follow'

### Fd 1 level deep

alias fd1='fd --exact-depth=1 --hidden --follow --exclude ".git"'

### Fd with configurable options

fdde() {
    local case_flag=""
    local depth_flag=""

    ### Enable case-insensitive search if the first argument is '-i'
    if [[ "$1" == "-i" ]]; then
        case_flag="--ignore-case"
        shift
    fi

    ### If a pattern is provided, use it; otherwise, display usage message
    if [ -z "$1" ]; then
        echo "Usage: fdde [-i] <pattern> [max-depth]"
        return 1
    fi

    ### Set the max-depth flag if a second argument is provided
    if [ -n "$2" ]; then
        depth_flag="--max-depth $2"
    fi

    ### Execute fd with the collected flags and the provided pattern
    fd $case_flag $depth_flag --glob "$1"
}

## Nxsiv

### Create thumbnails of all vids in a dir

vidt() {
    local thumb_dir="$HOME/.cache/video_thumbs"
    mkdir -p "$thumb_dir"

    ### Disable confirmation for rm (using local zsh option)
    setopt localoptions rmstarsilent
    rm -f "$thumb_dir"/*

    local videos
    videos=(*.mp4(N) *.mkv(N) *.avi(N) *.mov(N) *.webm(N) *.flv(N) *.wmv(N))

    if [ ${#videos[@]} -eq 0 ]; then
        echo "No video files found in the current directory."
        return 1
    fi

    for video in "${videos[@]}"; do
        local thumbnail="$thumb_dir/${video%.*}.jpg"
        if ! ffmpegthumbnailer -i "$video" -o "$thumbnail" -s 256 2>> "$HOME/.cache/video_thumbs/errors.log"; then
            echo "Error generating thumbnail for $video"
        fi
    done

    nsxiv -t "$thumb_dir"
}

## Expressvpn Legacy

vpnstrict() {
	sudo expressvpn disconnect || echo "cound not disconnect" exit 1
	sudo expressvpn refresh || echo "cound not refresh" continue
	sudo expressvpn preferences set network_lock strict || echo "could net set network lock on" exit 1
	sudo expressvpn protocol lightway_tcp || echo "could not set lightway protocol" continue
	sudo expressvpn connect || exit 1
}

alias vpnc='sudo expressvpn connect'
alias vpnd='sudo expressvpn disconnect && sudo expressvpn preferences set network_lock off'
alias vpns='sudo expressvpn status'
alias vpnr='sudo expressvpn refresh'
alias vpnauto='expressvpn autoconnect true'
alias vpnset='sudo expressvpn preferences set'
alias vpnl='sudo expressvpn list'
alias vpnblock='sudo expressvpn preferences set block_all false'
alias vpnproto='sudo expressvpn protocol lightway_tcp'

## Expressvpn Universal App

#alias vpnc='expressvpnctl connect'
#alias vpnd='expressvpnctl disconnect'
#alias vpns='expressvpnctl get vpnip && expressvpnctl status'
#alias vpnl='expressvpnctl get regions'
#alias vpnnoextras='expressvpnctl set blockAll false'
#alias vpnproto='expressvpnctl set protocol lightwayudp'
#alias checkvpn='expressvpnctl get connectionstate && expressvpnctl get dnsconfigured'
## -------------- Blocking ---------------- ##
#alias vpnlan='expressvpnctl set allowlan false'
#alias vpnnolan='expressvpnctl set allowlan true'
#alias vpnlocknet='sudo expressvpnctl set networklock true'
#alias vpnunlocknet='sudo expressvpnctl set networklock false'
## -------------- Tunneling --------------- ##
#alias vpnton='sudo expressvpnctl set splittunnel true'
#alias vpntoff='sudo expressvpnctl set splittunnel false'
#alias vpnbypass='f(){ sudo expressvpnctl set split-app bypass:"$1"; }; f'
#alias vpnadd='f(){ sudo expressvpnctl set split-app vpn:"$1"; }; f'
#alias vpnrm='f(){ sudo expressvpnctl set split-app remove:"$1"; }; f'
## -------------- Fuck The GUI -------------- ##
#alias vpncli='expressvpnctl background enable'

## Nvim

[ -x "$(command -v nvim)" ] && alias vim="nvim" vimdiff="nvim -d"
alias magit="nvim -c MagitOnly"

## UFW

alias ufwd='sudo ufw disable'
alias ufws='sudo ufw status'
ufwr() {
    if yes | sudo ufw reset; then :; else echo "Failed to reset ufw"; fi
    sudo ufw default deny incoming || { echo "Failed to set default deny incoming"; return 1; }
    sudo ufw default allow outgoing || { echo "Failed to set default allow outgoing"; return 1; }
    sudo ufw enable || { echo "Failed to enable ufw"; return 1; }
}

## Micro

alias sm='sudo micro'

## Bleachbit

alias bleachcache='sudo bleachbit --clean system.cache system.localizations system.trash ; sudo paccache -vrk 2 || return 0'
alias bleachchrome='bleachbit --clean chromium.cache chromium.dom thumbnails.cache'

## Garuda-update

alias garuda-refreshkeys='garuda-update remote keyring'
alias garuda-reinstallallpkgs='garuda-update remote reinstall'
alias garuda-resetaudio='garuda-update reset-audio'

## Dracut

### This will pipe to sh to execute: "dracutk | sh"

alias dracutzen='echo "sudo dracut --force --kver=$(uname -r) /boot/initramfs-linux-zen.img --enhanced-cpio --early-microcode --fstab && sudo grub-install && sudo grub-mkconfig -o /boot/grub/grub.cfg"'
alias dracutfallback='echo "sudo dracut --force /boot/initramfs-linux-fallback.img --enhanced-cpio --early-microcode --fstab && sudo grub-install && sudo grub-mkconfig -o /boot/grub/grub.cfg"'

## SSH

sshpin() {
	ssh-keygen -R 192.168.1.91
	ssh-keyscan -t ed25519 192.168.1.91 >> ~/.ssh/known_hosts
	ssh-keygen -H -f ~/.ssh/known_hosts
	rm -f ~/.ssh/known_hosts.old
	ssh-keygen -F 192.168.1.91
}
alias ssha='eval $(ssh-agent -s) && ssh-add'
alias sshid='xclip -sel clip < ~/.ssh/id_ed25519.pub || cat ~/.ssh/id_ed25519.pub | wl-copy'
alias chssh='chmod 700 ~/.ssh && chmod 600 ~/.ssh/authorized_keys'

#alias cleanssh="sed -i 18d .ssh/known_hosts"

## NTP

alias restartntp='sudo systemctl stop ntpd.service && sudo pacman -Syu ntp'
alias fixntp='sudo ntpd -qg && sleep 10 && sudo hwclock -w'

## Clipboard

alias paste='wl-paste'
alias copy='wl-copy <'
#paste_cmd() {
#    wl-paste | "$@"
#}
#copy_cmd() {
#    "$@" | wl-copy
#}
#alias copy='wl-copy <'

## BTRFS

alias btrfs='sudo \btrfs'
alias scrub='sudo \btrfs scrub start'
alias scrubstat='sudo \btrfs scrub status'
alias btrfsls='sudo \btrfs filesystem show'
#alias btrfsfs='sudo btrfs filesystem df'
#alias btrfsli='sudo btrfs su li $PWD -t'

## Snapper

alias snapcroot="sudo snapper -c root create-config /"
alias snapchome="sudo snapper -c home create-config /home"
alias snapli="sudo snapper list"
alias snapcr="sudo snapper -c root create"
alias snapch="sudo snapper -c home create"

## Oh My ZSH

#alias oz="svim ~/.zshrc"
#alias oc="cd ~/.oh-my-zsh/custom/"
#alias omzp="echo -e '\033[1;36mPlugins:\033[0m'; awk -F'=' '/^plugins/{gsub(/[\(\)]/, \"\"); split(\$2, a, \" \"); for(i in a) print a[i]}' ~/.zshrc"
#alias omzl='omz plugin list'
#alias omzi='omz plugin info'

## Network____________________________________________________________________________________________

alias restartnetwork='sudo systemctl restart NetworkManager'

alias restartnetwork2='sudo ip link set down enp2s0 && sudo ip link set up enp2s0'

fixresolv() {
    sudo chattr -i /etc/resolv.conf
    echo -e "nameserver ::1
nameserver 127.0.0.1
options edns0 single-request-reopen" | sudo tee /etc/resolv.conf
    sudo chattr +i /etc/resolv.conf
}

## List traffic on :80

allports() {
    local output
    if output=$(ss -nat 2>/dev/null); then
        :
    else
        output=$(netstat -nat 2>/dev/null)
    fi
    echo "$output" | grep -E ":80[^0-9]" | wc -l
}

## List 20 awk conn :80

httpports() {
    sudo tcpdump -i eth0 -tnn dst port 80 -c 1000 | awk -F"." '{print $1"."$2"."$3"."$4}' | sort | uniq -c | sort -nr | head -n 20
}

## List 20 syn conn :80

synports() {
    local output
    if output=$(ss -an 2>/dev/null | awk '/SYN/ {print $5}'); then
        :
    else
        output=$(netstat -an 2>/dev/null | awk '/SYN/ {print $5}')
    fi
    echo "$output" | awk -F: '{print $1}' | sort | uniq -c | sort -nr | head -n 20
}

## List 100 conn sorted: uptime, instance sum

consume100() {
  awk '($NF > 60 && $7~/\.php/){print $7}' "$(retlog)" | sort -n | uniq -c | sort -nr | head -n 100
  # if django website or other website make by no suffix language
  #awk '{print $7}' "$(retlog)" | sort -n | uniq -c | sort -nr | head -n 100
}

## Python____________________________________________________________________________________

### Invoke without virtual environment:

syspip() {
    PIP_REQUIRE_VIRTUALENV="" pip "$@"
}
syspip2() {
    PIP_REQUIRE_VIRTUALENV="" pip2 "$@"
}
syspip3() {
    PIP_REQUIRE_VIRTUALENV="" pip3 "$@"
}

## Virtualenv

### create (if needed) & activate a named venv
py() {
  local name="${1:-default}"                     # default venv if no name given
  local base="$XDG_DATA_HOME/virtualenv"         # centralized venv storage
  local dir="$base/$name"

  mkdir -p "$base"

  if [[ ! -d "$dir" ]]; then
    echo "Creating virtualenv: $name"
    python -m venv "$dir"
  fi

  source "$dir/bin/activate" --prompt "üíÄ($name) "
}

### activate then cd into the venv directory
pycd() {
  py "$1"
  cd "$XDG_DATA_HOME/virtualenv/${1:-default}"
}

#alias pyvenv='source $XDG_DATA_HOME/virtualenv/bin/activate --prompt üíÄ'
#alias pyvenvcd='source $XDG_DATA_HOME/virtualenv/bin/activate --prompt üíÄ && cd $XDG_DATA_HOME/virtualenv'

## Pyfiglet:

figletbanner() {
    if [[ "$1" == "--help" || "$1" == "-h" ]]; then
        echo "Usage: figletc \"your text here\""
        echo "Generates stylized text using pyfiglet with line_blocks font and cyan color."
        return
    fi

    if ! command -v pyfiglet >/dev/null 2>&1; then
        echo "Error: pyfiglet is not installed. Please install it using pip:"
        echo "       pip install pyfiglet"
        return 1
    fi

    if ! command -v lolcat >/dev/null 2>&1; then
        echo "Error: lolcat is not installed. Please install it using your package manager:"
        echo "       sudo pacman -S lolcat"
        return 1
    fi

    pyfiglet --font=line_blocks --normalize-surrounding-newlines "$@" | lolcat -F 0.5
}

## Multimedia________________________________________________________________________________

## W3M

alias w3m='w3m https://yandex.com'

## Wget

alias imgscrape='wget -r -l1 --no-parent -nH -nd -P/tmp -A".gif,.jpg,.png" http://example.com/images'
alias mirrorsite='wget -m -k -K -E -e robots=off'

## Transmission

alias trem='transmission-remote'

## Youtube-Viewer

#alias ffmpeg="ffmpeg -hide_banner"
alias ytt='yt-dlp --skip-download --write-thumbnail'
alias YT='youtube-viewer --order=date'
alias yta='yt-dlp -x -f bestaudio/best'

## Mpv

playdir() {
    if [[ -z "$1" ]]; then
        echo "No file or directory provided." >&2
        return 1
    fi
    if [[ -d "$1" ]]; then
        target="$1"
    else
        target=$(dirname "$1")
    fi
    cd "$target" || return 1
    mpv --playlist=<(find "$(pwd)" -maxdepth 3 -type f \( \
          -iname '*.mp4' -o -iname '*.wmv' -o -iname '*.mkv' -o \
          -iname '*.avi' -o -iname '*.mov' -o -iname '*.mpeg' -o \
          -iname '*.ts'  -o -iname '*.m4v' -o -iname '*.gif' -o \
          -iname '*.png' -o -iname '*.jpg' -o -iname '*.jpeg' \
          -iname "*.3gp" \)) --shuffle=yes --loop-playlist=inf \
	  --input-ipc-server=/tmp/mpvsocket --no-resume-playback
}

#playdir() {
#    \ls $PWD > dirplaylist.txt
#    mpv --playlist=dirplaylist.txt --shuffle=yes --loop=no || rm dirplaylist.txt
#}
#alias mpvplaylist='mpv --input-ipc-server=/tmp/mpvsocket --playlist=/home/andro/mpv_playlist.txt'

## Yt-dlp

#ytdl() {
#  yt-dlp --add-metadata \
#         --embed-metadata \
#         --external-downloader aria2c \
#         --external-downloader-args "-c -j 3 -x 3 -s 3 -k 1M" \
#         -f "315/313/308/303/302/247/244/137+bestaudio/best" \
#         --merge-output-format webm \
#         --no-playlist \
#         --no-mtime \
#         "$@"
#}

#ytf() {
#    local url="$1"
#    yt-dlp --list-formats \
#           "$url"
#}

#ytp() {
#  yt-dlp --add-metadata \
#         --embed-metadata \
#         --external-downloader aria2c \
#         --external-downloader-args "-c -j 3 -x 3 -s 3 -k 1M" \
#         -f "315/313/308/303/302/247/244/137+bestaudio/best" \
#         --yes-playlist \
#    --write-playlist-metafiles \
#    --concat-playlist always \
#         "$@"
#}

## FFMPEG

alias 720p='() { file="$(fzf)"; [ -n "$file" ] && ffmpeg -i "$file" -vf "scale='\''if(gt(a,16/9),1280,-2)':'if(gt(a,16/9),-2,720)'\''" "${file%.*}_720.jpg"; }'

function mergelist() {
	local files
  	files=($(fzf --multi))
  	[[ ${#files[@]} -eq 0 ]] && return
  	/home/git/clone/4ndr0666/scr/media/ffmpeg-concat "${files[@]}"
}

function stripvideo() {
	local video="$1"
	if [[ ! -f "$video" ]]; then
    		echo "Error: '$video' does not exist or is not a file." >&2
    	return 1
  	fi
  	local base_name="stripped_video"
  	local extension=".mp4"
  	local counter=1
  	while [[ -e "$PWD/${base_name}${counter}${extension}" ]]; do
    		((counter++))
  	done
  	local save_name="$PWD/${base_name}${counter}${extension}"
  	ffmpeg -i "$video" -map_metadata -1 -map_chapters -1 -c copy "$save_name"
  	echo "Stripped video saved as: $save_name"
}

## Exiftool

function stripimage() {
  local input="$1"
  if [[ ! -f "$input" ]]; then
    echo "Error: '$input' does not exist." >&2
    return 1
  fi
  local ext="${input##*.}"
  local base="${input%.*}"
  local output="${base}_stripped.${ext}"
  ffmpeg -hide_banner -loglevel error -i "$input" -map_metadata -1 -c:v png "$output" && echo "‚úÖ Stripped image saved as: $output"
}

## Redgifs

reddl() {
    yt-dlp --external-downloader aria2c \
           --external-downloader-args "-c -j 3 -x 3 -s 3 -k 1M" \
           -o "/home/andro/Downloads/%(title)s.%(ext)s" \
           "$@"
}

## N-m3u8-dl

m3dl() {
    local url="$1"
    local save_dir="/storage/Downloads"
    local base_name="m3dl_download"
    local extension=".mp4"
    local counter=1

    while [ -e "${save_dir}/${base_name}_${counter}${extension}" ]; do
        counter=$((counter + 1))
    done

    local save_name="${save_dir}/${base_name}_${counter}${extension}"

    \n-m3u8dl-re "$url" \
                --save-name "$save_name" \
                --use-ffmpeg-concat-demuxer \
                --thread-count 32 \
                --download-retry-count 5 \
                --auto-select \
                --live-real-time-merge \
                --mux-after-done format=mp4:muxer=ffmpeg:keep=false \
                --tmp-dir "/storage/tmp" \
                --save-dir "$save_dir" \
                --log-level INFO \
                -H "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0" \
                -H "Referer: https://example.com" \
                -H "Cookie: sessionid=abc123; other_cookie=value"
}

## Package Management____________________________________________________________________________

## Pkglist

alias bigpkg="expac -H M '%m\t%n' | sort -h | nl"
alias rip="expac --timefmt='%Y-%m-%d %T' '%l\t%n %v' | sort | tail -200 | nl"
alias riplong="expac --timefmt='%Y-%m-%d %T' '%l\t%n %v' | sort | tail -3000 | nl"
alias gitpkg="pacman -Q | grep -i '\-git' | wc -l"
alias pkgbysize="expac -Q '%m - %n %v' | sort -n -r"
alias mkpkglist='cat /tmp/pacui-ls'

## Reflector

alias mirrors='sudo reflector --latest 10 --age 2 --fastest 10 --protocol https --sort rate --save /etc/pacman.d/mirrorlist'

## Pacman:

alias fixpacman='sudo unlink /var/lib/pacman/db.lck'
alias fixpacman2='sudo unlink /var/cache/pacman/pkg/cache.lck'
alias cleanpacman="sudo find /var/cache/pacman/pkg/ -iname '*.part' -delete"
alias checkdb='sudo pacman -Dk'
alias findpkg='sudo pacman -Fyx'
alias eol='comm -23 <(pacman -Qqm | sort) <(curl https://aur.archlinux.org/packages.gz | gzip -cd | sort)'

## Yay

#alias yay='yay --builddir "/home/build" --sortby votes'
#alias yay='yay --answerdiff no --builddir "/home/build" --cleanafter --cleanmenu --sortby votes'
alias yaydeps='yay --sudoloop --refresh --singlelineresults --sysupgrade --timeupdate --verbose'
alias yayskip='yay -S --mflags --skipinteg'
alias yayow='yay -S --overwrite="*" --noconfirm'
alias trizenskip='trizen -S --skipinteg'
alias update='sudo pacman -Sy && yay --noconfirm --sudoloop --noprogressbar --needed |& tee -a /Nas/Backups/yay.log'
yaysearch() {
    read -r -p "Choose a search parameter (1-5): " search_param
    case $search_param in
        1) yay --singlelineresults --groups --provides --searchby name ;;
        2) yay --singlelineresults --groups --provides --searchby desc ;;
        3) yay --singlelineresults --groups --provides --searchby maintainer ;;
        4) yay --singlelineresults --groups --provides --searchby packager ;;
        5) yay --singlelineresults --groups --provides --searchby depends ;;
        *) echo "Invalid choice. Please choose a number between 1 and 5." ;;
    esac
}


# Fuckin-Do-It (fn)

alias fninstall="yay -S --needed --cleanafter --cleanmenu --devel --noconfirm --rebuild --refresh --sudoloop --sysupgrade --overwrite='*' --disable-download-timeout --pgpfetch=false --removemake --redownload --batchinstall=false --answerclean=yes --answerdiff=no --answeredit=no"
alias fnupdate='yay -Syyu --noconfirm --disable-download-timeout --removemake --rebuild --pgpfetch=false --bottomup --overwrite="*"'
alias fnremove='yay -Rddn --noconfirm'


# Skip Integrity Check

alias paruskip='paru -S --mflags --skipinteg'
alias yayskip='yay -S --mflags --skipinteg'
alias trizenskip='trizen -S --skipinteg'


# Pacman.conf
pacmansigoff() {
    read -r -p "Are you sure you want to disable PGP signature verification? (yes/no): " answer
    if [[ $answer == "yes" ]]; then
        if sudo cp --preserve=all -f /etc/pacman.conf /etc/pacman.conf.backup; then
            sudo sed -i '/^SigLevel/ s/Required/Never/' /etc/pacman.conf && echo "PGP signature verification bypassed."
        else
            echo "Failed to create backup. Aborting."
        fi
    else
        echo "Operation canceled."
    fi
}

alias pacmansigon="if [ -f /etc/pacman.conf.backup ]; then if sudo cp --preserve=all -f /etc/pacman.conf.backup /etc/pacman.conf; then sudo rm /etc/pacman.conf.backup && echo 'PGP signature verification restored.'; else echo 'Failed to restore the original pacman.conf. Aborting.'; fi; else echo 'Backup file not found. Cannot restore.'; fi"

# GPG
alias fixdirmngr='sudo dirmngr </dev/null'
#alias chgpg='sudo chown -R $(whoami):$(whoami) ~/.gnupg && chmod 700 ~/.gnupg && chmod 600 ~/.gnupg/*'
alias rmgpg='sudo rm -r /etc/pacman.d/gnupg'
alias fixpacmankey='sudo pacman -S archlinux-keyring && sudo pacman-key --populate'
alias fixpacmankey2='gpg-agent --homedir /etc/pacman.d/gnupg --use-standard-socket --daemon'
#alias fixgpgkey="echo 'keyring /etc/pacman.d/gnupg/pubring.gpg' >> $HOME/.gnupg/gpg.conf && sudo pacman-key --populate archlinux"
alias gpgkeyserver2="sudo gpg --keyserver hkps://keys.openpgp.org/ --search-keys user-id"
alias generate-keyserver='gpg --full-generate-key && gpg --import /usr/share/pacman/keyrings/archlinux* && gpg --recv-keys --keyserver hkp://pool.sks-keyservers.net && pacman-key --init && pacman-key --populate archlinux'

# Git
alias gstat='git status'
alias gstash='git stash --all'
alias gclear='git stash clear'
#alias ghr='git reset --hard'
#alias gfs='git-lfs'
#alias ga='git add'
#alias gp='git push origin main'

#alias gupdate='gcomp && gh tidy && gh setup'

gupdate() {
  setopt errexit nounset pipefail     # abort on error, no unset vars, fail pipelines

  local mode make_backup keep_backups
  local source_dir repo_dir target_dir backup_root
  local rsync_args ssh_keys ts archive backups to_prune msg

  mode="${1:-addonly}"                 # "addonly" or "mirror"
  make_backup="${2:-false}"            # "true" to tarball before sync
  keep_backups="${3:-7}"               # how many archives to keep

  source_dir="${HOME}/.config/zsh"
  repo_dir="/home/git/clone/dotfiles"
  target_dir="${repo_dir}/home/andro/.config/zsh"
  backup_root="/Nas/Backups/git"

  rsync_args=(-av --update --progress)
  if [[ "${mode}" == "mirror" ]]; then
    rsync_args+=(--delete)
  fi

  ssh_keys="$(ssh-add -l 2>/dev/null || true)"
  if [[ -z "${ssh_keys}" ]]; then
    echo "‚û°Ô∏è  Loading SSH key into agent‚Ä¶"
    ssh-add "${HOME}/.ssh/id_ed25519" \
      || { echo "‚ùå  Failed to add SSH key. Aborting."; return 1; }
  fi

  if [[ "${make_backup}" == "true" ]]; then
    mkdir -p "${backup_root}" \
      || { echo "‚ùå  Cannot create backup_root. Aborting."; return 1; }
    ts="$(date +%F_%H%M%S)"
    archive="${backup_root}/dotfiles_${ts}.tar.gz"
    echo "üõ°Ô∏è  Creating backup: ${archive}"
    tar -czf "${archive}" -C "${repo_dir}" . \
      || { echo "‚ùå  Backup failed. Aborting."; return 1; }

    IFS=$'\n' backups=( $(ls -1t "${backup_root}"/dotfiles_*.tar.gz 2>/dev/null) )
    if (( ${#backups[@]} > keep_backups )); then
      to_prune=( "${backups[@]:keep_backups}" )
      rm -- "${to_prune[@]}" \
        || echo "‚ö†Ô∏è  Failed to prune some old backups."
    fi
  fi

  echo "‚û°Ô∏è  Starting dotfiles sync (mode=${mode})‚Ä¶"
  rsync "${rsync_args[@]}" "${source_dir}/" "${target_dir}/" \
    || { echo "‚ùå  Rsync failed. Aborting."; return 1; }

  echo "‚ûï  Staging new & modified files‚Ä¶"
  git -C "${repo_dir}" add -u . \
    || { echo "‚ùå  'git add -u' failed."; return 1; }
  git -C "${repo_dir}" add . \
    || { echo "‚ùå  'git add .' failed."; return 1; }

  if git -C "${repo_dir}" diff --cached --quiet; then
    echo "‚úÖ  No changes to commit."
  else
    msg="chore(dotfiles): sync zsh @ $(date +%Y%m%d_%H%M%S)"
    git -C "${repo_dir}" commit -m "${msg}" \
      || { echo "‚ùå  Commit failed."; return 1; }
    echo "‚úîÔ∏è  Committed: ${msg}"
  fi

  echo "üì§  Pushing to origin/main‚Ä¶"
  git -C "${repo_dir}" push origin main \
    || { echo "‚ùå  Git push failed."; return 1; }

  echo "üßπ  Running 'gh tidy'‚Ä¶"
  gh -R 4ndr0666/dotfiles tidy --yes > /dev/null 2>&1 \
    || { echo "‚ùå  gh tidy failed."; return 1; }

  echo "‚öôÔ∏è  Running 'gh setup'‚Ä¶"
  gh -R 4ndr0666/dotfiles setup --yes > /dev/null 2>&1 \
    || { echo "‚ùå  gh setup failed."; return 1; }

  echo "‚úÖ  gupdate completed successfully."
}


#gupdate() {
#    local source_dir="$HOME/.config/zsh/"
#    local target_dir="/home/git/clone/dotfiles/home/andro/.config/zsh/"
#    local repo_dir="/home/git/clone/dotfiles/"
#
#    echo "Copying updated dotfiles from '${source_dir}' to '${target_dir}'..."
#    if ! rsync -av --update --progress "${source_dir}"* "${target_dir}"; then
#        echo "Error: Failed to copy files from ${source_dir} to ${target_dir}."
#        return 1
#    fi
#
#    if ! cd "${repo_dir}"; then
#        echo "Error: Failed to change directory to ${repo_dir}."
#        return 1
#    fi
#
#    if ! gcomp; then
#        echo "Error: gcomp failed. Aborting workflow."
#        return 1
#    fi
#
#    if ! gh tidy; then
#        echo "Error: gh tidy failed."
#        return 1
#    fi
#
#    if ! gh setup; then
#        echo "Error: gh setup failed."
#        return 1
#    fi
#}

gignore() {
    ### Ensure a pattern is provided
    if [ -z "$1" ]; then
        echo "Usage: gitignore_add <pattern>"
        return 1
    fi

    local pattern="$1"
    local gitignore_file="$PWD/.gitignore"

    ### Create the file if it doesn't exist
    if [ ! -f "$gitignore_file" ]; then
        touch "$gitignore_file"
        echo "Created $gitignore_file"
    fi

    ### Check if the pattern already exists (exact match)
    if grep -Fxq "$pattern" "$gitignore_file"; then
        echo "Pattern '$pattern' already exists in $gitignore_file"
    else
        echo "$pattern" >> "$gitignore_file"
        echo "Added pattern '$pattern' to $gitignore_file"
    fi
}

gclone() {
    if [[ -z "$1" ]]; then
        echo "Error: No repository URL provided."
        echo "Usage: gclone <repository-url>"
        return 1
    fi

    repo_name=$(basename "$1" .git)

    if [[ -d "$repo_name" ]]; then
        read -p "Directory '$repo_name' already exists. Do you want to force clone into it? [y/N]: " confirm
        if [[ "$confirm" != [yY] ]]; then
            echo "Clone operation aborted."
            return 1
        else
            echo "Warning: Existing directory will be used."
        fi
    fi

    temp_dir=$(mktemp -d)
    git clone --depth 1 --filter=blob:none --bare "$1" "$temp_dir" > /dev/null 2>&1
    repo_size=$(du -sm "$temp_dir" | cut -f1)
    rm -rf "$temp_dir"

    if [[ "$repo_size" -le 25 ]]; then
        echo "Small repository detected ($repo_size MB). Performing a full clone."
        depth_flag=""
    else
        echo "Large repository detected ($repo_size MB). Performing a shallow clone with --depth 5."
        depth_flag="--depth 5"
    fi

    if git clone $depth_flag "$@"; then
        cd "$repo_name" || { echo "Error: Failed to change into directory '$repo_name'."; return 1; }
        echo "Successfully cloned and switched to '$repo_name'."

        if [[ -n "$depth_flag" ]]; then
            read -p "Would you like to fetch more history (convert to full clone)? [y/N]: " fetch_more
            if [[ "$fetch_more" == [yY] ]]; then
                git fetch --unshallow
                echo "Full history fetched."
            fi
        fi
    else
        echo "Error: Failed to clone the repository."
        return 1
    fi
}

gadd() {
	local choice
	choice=$(\ls "$PWD" | fzf --prompt="Select item(s) to add: ")
	[ -n "$choice" ] && git add "$choice" || echo "No selection made."
}

gcomp() {
        git commit -m "$*"
        git push origin main
}

gcompn() {
        git commit -m "$*" --no-verify
        git push origin main
}

gauto() {
    if ! git diff-index --quiet HEAD --; then

        ### Gather information about the changes
        added=$(git status --porcelain | grep "^A" | wc -l)
        modified=$(git status --porcelain | grep "^ M" | wc -l)
        deleted=$(git status --porcelain | grep "^D" | wc -l)

        commit_message="Auto-commit: ${added} added, ${modified} modified, ${deleted} deleted"

        git add -A

        if ! git commit -m "$commit_message"; then
            echo "Error: Commit failed. Aborting."
            return 1
        fi

        if ! git pull --rebase; then
            echo "Error: Pull failed. Aborting."
            return 1
        fi

        if ! git push; then
            echo "Error: Push failed. Aborting."
            return 1
        fi

        echo "Changes committed, pulled, and pushed successfully."
        echo "Commit message: $commit_message"
    else
        echo "No changes detected. Nothing to commit."
    fi
}

gssh() {
    eval "$(ssh-agent -s)"
    ssh-add ~/.ssh/github
    ssh -T git@github.com
}

gsearch() {
    if command -v ag &> /dev/null; then
        git exec ag "$1"
    elif command -v rg &> /dev/null; then
        git exec rg "$1"
    else
        git exec grep -r "$1"
    fi
}

grmcache() {
    cache_dir="${XDG_CACHE_HOME:-$HOME/.cache}/git"
    if [[ -d "$cache_dir" ]]; then
        read -p "Are you sure you want to delete Git cache at $cache_dir? [y/N]: " confirm
        if [[ "$confirm" == [yY] ]]; then
            rm -rf "$cache_dir"
            echo "Git cache deleted."
        else
            echo "Git cache deletion aborted."
        fi
    else
        echo "No Git cache found at $cache_dir."
    fi
}

groot() {
    if git rev-parse --show-toplevel &> /dev/null; then
        cd "$(git rev-parse --show-toplevel)" || { echo "Error: Failed to change to Git repository root."; return 1; }
        echo "Moved to Git repository root."
    else
        echo "Error: Not inside a Git repository."
        return 1
    fi
}

gremote() {
    if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
        echo "Not a git repository. Please navigate to a git repository and try again."
        return 1
    fi

    printf "Enter your GitHub username (default: 4ndr0666): "
    read -r username
    username=${username:-"4ndr0666"}

    printf "Enter the repository name: "
    read -r repo_name

    local url="git@github.com:${username}/${repo_name}.git"

    if git remote get-url origin &> /dev/null; then
        read -p "Are you sure you want to remove the current 'origin' remote? [y/N]: " confirm
        if [[ "$confirm" != [yY] ]]; then
            echo "Remote origin removal canceled."
            return 1
        fi
        git remote remove origin
        echo "Old 'origin' remote removed."
    fi

    git remote add origin "$url"
    echo "New 'origin' remote set to $url."

    git remote -v
}

gsetup() {
    local repo_name commit_msg branch_name
    git init

#    printf "Enter your GitHub username (default: 4ndr0666): "
#    read -r username
#    username=${username:-"4ndr0666"}

    printf "Enter the name of the GitHub repository: "
    read -r repo_name

    git remote add origin "git@github.com:4ndr0666/${repo_name}.git"
    git add .

    echo "Enter a commit message for the initial commit (default: 'Initial commit'): "
    read -r commit_msg

    commit_msg=${commit_msg:-"Initial commit"}
    git commit -m "$commit_msg"

    printf "Enter the branch name to push to (default: main): "
    read -r branch_name

    branch_name=${branch_name:-"main"}

    git push -u origin "$branch_name"
}

# Custom Powerdown
cleanup_session() {
    echo "Begining custom shutdown..."
    # Define the list of processes to check and terminatete
    processes=("polkit-gnome-authentication-agent-1" "timeshift" "brave-beta" "pacman")

    # Loop through each process and attempt to terminate it gracefully
    for process in "${processes[@]}"; do
        if pgrep -x "$process" > /dev/null; then
            echo "Sending SIGTERM to $process..."
            sudo pkill -15 -x "$process"

            ### Wait up to 5 seconds for the process to terminate
            timeout=5
            counter=0
            while pgrep -x "$process" > /dev/null && [ $counter -lt $timeout ]; do
                sleep 1
                counter=$((counter + 1))
            done

            if pgrep -x "$process" > /dev/null; then
                echo "$process did not terminate after SIGTERM. Sending SIGKILL..."
                sudo pkill -9 -x "$process"
                sleep 1
                if pgrep -x "$process" > /dev/null; then
                    echo "Failed to terminate $process even after SIGKILL."
                else
                    echo "$process terminated successfully after SIGKILL."
                fi
            else
                echo "$process terminated gracefully."
            fi
        else
            echo "$process not running."
        fi
    done

    ### Clear temporary files or session caches
    echo "Clearing temporary files and session caches..."
    sudo rm -rf /tmp/*
    sudo rm -rf /var/tmp/*

    ### Additional cleanup for user session state or session artifacts (optional)
    echo "Removing any lingering lock files or session artifacts..."
    sudo rm -f /run/user/$(id -u)/lock/*

    ### Sync filesystem buffers
    echo "Syncing filesystem buffers..."
    sync
}

alias sdn="cleanup_session && echo 'Shutting down...' && sudo shutdown -h now"
alias ssr="cleanup_session && echo 'Rebooting...' && sudo reboot -h now"
alias magic='sudo /usr/local/bin/magic.sh'

# 4ndr0tools

# 4ndr0cht: cheatsheets ~/.cheaters
cht() {
    local cheats
    cheats=("$HOME/.cheater/"*.md)
    local choice
    choice=$(printf "%s\n" "${cheats[@]}" | fzf --prompt="Select a cheat sheet: ")
    [ -n "$choice" ] && glow "$choice" || echo "No cheat sheet selected."
}

# 4ndr0conf: modular config file editor
edit_config() {
    local file_path="$1"
    if [[ $file_path ]]; then
        sudo chattr -i "$file_path"
        sudo -E nvim "$file_path"
    else
        echo "File path not provided."
    fi
}

alias svim='edit_config'
alias vssh='edit_config /etc/ssh/ssh_config'
alias valias='edit_config "$ZDOTDIR/aliasrc"'
alias vfunc='edit_config "$ZDOTDIR/functions.zsh"'
alias vpac='edit_config /etc/pacman.conf'
alias vgrub='edit_config /etc/default/grub'
alias vgrubc='edit_config /boot/grub/grub.cfg'
alias vmkinit='edit_config /etc/mkinitcpio.conf'
alias vmirror='edit_config /etc/pacman.d/mirrorlist'
alias vchaotic='edit_config /etc/pacman.d/chaotic-mirrorlist'
alias vfstab='edit_config /etc/fstab'
alias vzpro='edit_config "$ZDOTDIR/.zprofile"'
alias vbash='edit_config "$HOME/.bashrc"'
alias vzsh='edit_config "$ZDOTDIR/.zshrc"'
alias vhosts='edit_config /etc/hosts'
alias vmpv='edit_config "$XDG_CONFIG_HOME"/mpv/mpv.conf'
alias vfire='edit_config "$XDG_CONFIG_HOME"/wayfire.ini'
alias vbar='edit_config "$XDG_CONFIG_HOME"/wayfire/waybar/config'
alias vhostname='edit_config /etc/hostname'

# 4ndr0cuts: directory shortcuts
goto() {
    local dir="$1"
    if [[ -d "$dir" ]]; then
        cd "$dir" || exit
    else
        echo "Directory not found: $dir"
    fi
}
# /home:
alias dc='goto ~/Documents'
alias dl='goto ~/Downloads'
alias vid='goto ~/Videos'
alias pic='goto ~/Pictures'
alias screens='goto /home/andro/Pictures/Screenshots'
alias conf='goto ~/.config'
alias wconf='goto ~/.config/wayfire'
alias zconf='goto ~/.config/zsh'
alias mconf='goto ~/.config/mpv'
alias hconf='goto ~/.config/hypr'
alias ob='goto ~/.config/openbox'
alias obt='goto ~/.config/openbox/themes'
# /storage:
alias s1='goto /storage'
alias s1dl='goto /storage/Downloads'
alias s1pic='goto /storage/Pictures'
alias s1vid='goto /storage/Videos'
alias streamdir='goto /storage/streamlink'
# /sto2:
alias s2='goto /sto2'
alias s2dl='goto /sto2/Downloads'
alias s2pic='goto /sto2/Pictures'
alias s2vid='goto /sto2/Videos'
alias gym='goto /sto2/Gym'
alias jd='goto /sto2/JD'
alias ari='goto /storage/Ari_cloud'
# /s3
alias s3='goto /s3'
alias s3dl='goto /s3/Downloads'
alias s3vid='goto /s3/Videos'
# /23.1
alias 23e='goto /23.1/Edits'
alias 23f='goto /23.1/Edits/F/'
alias 23='goto /23.1'
alias 23dl='goto /23.1/Downloads'
alias 23vid='goto /23.1/Videoenhancement'
alias 23pic='goto /23.1/Images'
alias 23jd='goto /23.1/JD'
alias cloud='goto /23.1/Thecloud'
# /Nas:
alias nas='goto /Nas'
alias nnas='goto /Nas/Nas'
alias sand='goto /Nas/sandbox'
alias sando='goto /Nas/sandbox/overrides'
alias sande='goto /Nas/sandbox/extract'
alias sandt='goto /Nas/sandbox/temp'
alias sandpkg='goto /Nas/sandbox/pkgs'
alias sandplay='goto /Nas/sandbox/playground'
alias fan='goto /Nas/Fanvue'
alias todo='goto /Nas/00todo'
alias nasc='goto /Nas/Nas/Cookie\ Backup\ Restore && cat *.ckz | wl-copy' # Cookie file
# /home/git:
alias g='goto /home/git/clone'
alias g4='goto /home/git/clone/4ndr0666'
alias gnas='goto /home/git/clone/4ndr0666/nas'
alias gdot='goto /home/git/clone/4ndr0666/dotfiles'
alias gbin='goto /home/git/clone/4ndr0666/scr'
alias ggpt='goto /home/git/clone/4ndr0666/gpt/'
# System directories:
alias et='goto /etc'
alias ske='goto /etc/skel'
alias bin='goto /usr/local/bin'
alias loc='goto ~/.local'
alias lbin='goto ~/.local/bin'
alias cheat='goto ~/.cheater'
alias lshare='goto ~/.local/share/'
alias lsrc='goto ~/.local/src/'
alias cac='goto ~/.cache'

# 4ndr0kill
killit() {
  emulate -L zsh
  local sig=15
  if (( $# > 0 )) && [[ $1 =~ ^[0-9]+$ ]]; then
    sig=$1
    shift
  fi
  local entries
  if (( EUID != 0 )); then
    entries=("${(@f)$(ps -f -u $EUID | sed 1d)}")
  else
    entries=("${(@f)$(ps -ef | sed 1d)}")
  fi
  local selected
  selected=$(printf "%s\n" "${entries[@]}" | fzf -m \
    --prompt="Select processes to kill (SIG$sig then SIGKILL fallback): " \
    --header="TAB: multi‚Äëselect, ENTER: confirm" \
    --ansi)
  if [[ -z $selected ]]; then
    print_message INFO "No processes selected."
    return 1
  fi
  local pid_list=("${(@f)$(printf "%s\n" "$selected" | awk '{print $2}')}")
  (( ${#pid_list} )) || {
    print_message ERROR "Failed to parse any PIDs."
    return 1
  }
  print_message WARNING "About to send SIG$sig to: ${pid_list[*]}"
  read -q "?Proceed? [y/N]: "
  echo
  [[ $REPLY =~ ^[Yy]$ ]] || {
    print_message INFO "Aborted."
    return 0
  }
  for pid in "${pid_list[@]}"; do
    if kill -"$sig" "$pid"; then
      print_message INFO "Sent SIG$sig to PID $pid"
    else
      print_message ERROR "Failed to send SIG$sig to PID $pid"
    fi
  done
  for pid in "${pid_list[@]}"; do
    for ((i=1; i<=5; i++)); do
      kill -0 "$pid" &>/dev/null || break
      sleep 1
    done

    if kill -0 "$pid" &>/dev/null; then
      print_message WARNING "PID $pid still alive‚Äîsending SIGKILL"
      if kill -9 "$pid"; then
        print_message SUCCESS "SIGKILL succeeded on $pid"
      else
        print_message ERROR "Failed to SIGKILL $pid"
      fi
    else
      print_message SUCCESS "PID $pid exited gracefully"
    fi
  done
}

# 4ndr0view: Quicly view configuration files
alias 00='bat --language=sh --paging=always ~/.config/zsh/aliasrc'
alias 0f='bat ~/.config/zsh/functions.zsh'
alias 0z='bat ~/.config/zsh/.zshrc'
alias 0p='bat ~/.config/zsh/.zprofile'


# NEW PROGS 

# Lazygit
alias lg='lazygit'

# Gau
alias gau='gau --config ~/.config/gau/.gau.toml'

# ------------------------- [ TYPOS ]

alias gerp='grep'
alias shudown='shutdown'
alias micor='micro'
alias cpoy='copy'
alias nvin='nbin'
alias cay='cat'
alias reloda='reload'
